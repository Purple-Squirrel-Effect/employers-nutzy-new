---
export interface Props {
  cards?: Array<{
    id: string;
    image: string;
    alt: string;
    title?: string;
    subtitle?: string;
    backgroundColor?: string;
  }>;
  className?: string;
}

const {
  cards = [
    {
      id: "card-1",
      image: "/api/placeholder/300/200",
      alt: "Brand Card 1",
      title: "gotiket",
      backgroundColor: "bg-blue-600",
    },
    {
      id: "card-2",
      image: "/api/placeholder/280/180",
      alt: "Brand Card 2",
      title: "Rijksen",
      subtitle: "Web Designer",
      backgroundColor: "bg-white",
    },
    {
      id: "card-3",
      image: "/api/placeholder/320/220",
      alt: "Brand Card 3",
      title: "gotiket",
      backgroundColor: "bg-purple-700",
    },
    {
      id: "card-4",
      image: "/api/placeholder/290/190",
      alt: "Brand Card 4",
      title: "Aleksandrs Baskakows",
      backgroundColor: "bg-white",
    },
    {
      id: "card-5",
      image: "/api/placeholder/310/210",
      alt: "Brand Card 5",
      backgroundColor: "bg-blue-900",
    },
    {
      id: "card-6",
      image: "/api/placeholder/300/200",
      alt: "Brand Card 6",
      title: "gotiket",
      backgroundColor: "bg-white",
    },
  ],
  className = "",
} = Astro.props;
---

<!-- Main Container with Side-by-Side Layout -->
<div
  class={`scattered-gallery-container !sticky w-full bg-gradient-to-br from-blue-400 via-blue-500 to-blue-600 overflow-hidden ${className}`}
  style="min-height: 200vh;"
>
  <!-- Background pattern -->
  <div class="absolute inset-0 opacity-10">
    <div class="absolute top-10 left-10 w-4 h-4 bg-white rounded-full"></div>
    <div class="absolute top-20 left-32 w-3 h-3 bg-white rounded-full"></div>
    <div class="absolute top-32 left-20 w-2 h-2 bg-white rounded-full"></div>
    <div class="absolute top-40 left-48 w-3 h-3 bg-white rounded-full"></div>
    <div class="absolute top-16 right-20 w-4 h-4 bg-white rounded-full"></div>
    <div class="absolute top-36 right-32 w-2 h-2 bg-white rounded-full"></div>
    <div class="absolute bottom-20 left-16 w-3 h-3 bg-white rounded-full"></div>
    <div class="absolute bottom-32 right-24 w-4 h-4 bg-white rounded-full">
    </div>
  </div>

  <!-- Split Layout Container -->
  <div class="relative w-full h-screen flex" id="split-container">
    <!-- Dynamic Content Container - holds both text and cards -->
    <div class="w-full relative" id="content-container">
      <!-- Text Content - positioned dynamically -->
      <div
        class="absolute inset-0 flex items-center pointer-events-none"
        id="text-container"
      >
        <div
          class="text-content w-1/2 px-8 max-w-lg pointer-events-auto flex items-center justify-center"
          id="text-content"
        >
          <div>
            <h1
              class="text-4xl md:text-5xl lg:text-6xl font-bold text-white mb-6 drop-shadow-2xl"
              id="main-title"
              style="text-shadow: 2px 2px 8px rgba(0,0,0,0.8);"
            >
              Make your job offers more visible
            </h1>
            <p
              class="text-lg md:text-xl text-white/90 drop-shadow-lg"
              id="main-description"
              style="text-shadow: 1px 1px 4px rgba(0,0,0,0.6);"
            >
              Transform scattered opportunities into organized, discoverable
              career paths
            </p>
          </div>
        </div>
      </div>

      <!-- Cards Container - spans full width for positioning flexibility -->
      <div class="absolute inset-0 pointer-events-none" id="cards-container">
        {
          cards.map((card, index) => (
            <div
              class={`gallery-card absolute ${card.backgroundColor} rounded-2xl shadow-2xl overflow-hidden transition-all duration-300 hover:scale-105 hover:shadow-3xl hover:z-50 pointer-events-auto`}
              data-card-id={card.id}
              data-index={index}
              data-card
            >
              {card.image && (
                <img
                  src={card.image}
                  alt={card.alt}
                  class="w-full h-full object-cover"
                  loading="lazy"
                />
              )}

              {(card.title || card.subtitle) && (
                <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent flex items-end">
                  <div class="p-4 text-white">
                    {card.title && (
                      <h3 class="text-lg font-bold mb-1">{card.title}</h3>
                    )}
                    {card.subtitle && (
                      <p class="text-sm opacity-90">{card.subtitle}</p>
                    )}
                  </div>
                </div>
              )}
            </div>
          ))
        }
      </div>

      <!-- Grid placeholders for target positions -->
      <div class="absolute inset-0 pointer-events-none" id="grid-container">
        <!-- Grid positioned on left side for target state -->
        <div class="w-1/2 flex items-center justify-center">
          <div
            class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 max-w-2xl w-full px-8"
            id="grid-layout"
          >
            {
              cards.map((card, index) => (
                <div
                  class="grid-placeholder bg-transparent rounded-2xl"
                  data-grid-index={index}
                  style="aspect-ratio: 4/3;"
                />
              ))
            }
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- End Split Layout Container -->
</div>
<!-- End Main Container -->

<!-- Additional content to demonstrate pinning effect -->
<section class="bg-gray-100 py-20">
  <div class="container mx-auto px-8 text-center">
    <h2 class="text-4xl font-bold text-gray-800 mb-6">Next Section</h2>
    <p class="text-xl text-gray-600 max-w-2xl mx-auto">
      This section appears after the pinned gallery section. The pinning effect
      keeps the gallery in view while you scroll through the transformation.
    </p>
  </div>
</section>

<section class="bg-white py-20">
  <div class="container mx-auto px-8 text-center">
    <h2 class="text-4xl font-bold text-gray-800 mb-6">More Content</h2>
    <p class="text-xl text-gray-600 max-w-2xl mx-auto">
      Additional content to provide more scrolling space and demonstrate the
      smooth transition after the pinned section.
    </p>
  </div>
</section>

<style>
  .scattered-gallery-container {
    position: relative;
    min-height: 100vh;
  }

  /* Split container for pinning */
  #split-container {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
  }

  /* Content container for flexible positioning */
  #content-container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  /* Text content positioning */
  .text-content {
    position: relative;
    transition: transform 0.1s ease-out;
    will-change: transform;
  }

  /* Gallery cards */
  .gallery-card {
    cursor: pointer;
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform, left, top, width, height;
    /* Default sizes that will be overridden by JS */
    width: 280px;
    height: 200px;
  }

  /* Grid container positioning */
  #grid-container {
    pointer-events: none;
  }

  /* Mobile responsive adjustments */
  @media (max-width: 768px) {
    .gallery-card {
      width: 200px;
      height: 150px;
    }

    .text-content {
      padding: 1rem;
    }
  }

  /* Small mobile adjustments */
  @media (max-width: 480px) {
    .gallery-card {
      width: 160px;
      height: 120px;
    }

    .scattered-gallery-container {
      padding: 1rem;
    }

    .text-content h1 {
      font-size: 2rem !important;
    }

    .text-content p {
      font-size: 1rem !important;
    }
  }

  /* Accessibility: Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .gallery-card {
      transition: none !important;
      transform: none !important;
    }

    .gallery-card:hover {
      transform: none !important;
    }

    .text-content {
      transition: none !important;
    }

    /* Disable all GSAP animations for reduced motion */
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* Enhanced shadow for hover state */
  .gallery-card:hover {
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
  }

  /* Focus styles for accessibility */
  .gallery-card:focus {
    outline: 2px solid rgba(255, 255, 255, 0.8);
    outline-offset: 4px;
  }

  /* Smooth performance optimizations */
  .gallery-card,
  .text-content {
    transform: translateZ(0); /* Force hardware acceleration */
  }
</style>

<script>
  import { gsap } from "gsap";
  import { Flip } from "gsap/Flip";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  // Register GSAP plugins
  gsap.registerPlugin(ScrollTrigger, Flip);

  interface CardPosition {
    x: number;
    y: number;
    rotation: number;
    width: number;
    height: number;
    zIndex: number;
  }

  interface AnimationState {
    isGridMode: boolean;
    flipState: any;
    scrollTrigger: ScrollTrigger | null;
  }

  // Seeded random number generator for consistent but random-looking layout
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  function generateCardPositions(
    cardCount: number,
    containerWidth: number,
    containerHeight: number
  ): CardPosition[] {
    const positions: CardPosition[] = [];
    const padding = 50; // Minimum distance from edges
    const minDistance = 100; // Minimum distance between card centers

    for (let i = 0; i < cardCount; i++) {
      let attempts = 0;
      let position: CardPosition;

      do {
        // Use index as seed for consistent positioning across reloads
        const seedX = i * 123 + attempts * 7;
        const seedY = i * 456 + attempts * 13;
        const seedRot = i * 789 + attempts * 19;
        const seedSize = i * 321 + attempts * 11;

        // Generate random position - constrain to right half of container (initial state)
        const rightHalfStart = containerWidth / 2;
        const rightHalfWidth = containerWidth / 2;
        const x =
          rightHalfStart +
          padding +
          seededRandom(seedX) * (rightHalfWidth - padding * 2 - 300);
        const y =
          padding + seededRandom(seedY) * (containerHeight - padding * 2 - 250);

        // Random rotation between -20 and 20 degrees
        const rotation = (seededRandom(seedRot) - 0.5) * 40;

        // Slight size variation
        const sizeVariation = seededRandom(seedSize) * 40 - 20;
        const width = Math.max(200, 280 + sizeVariation);
        const height = Math.max(150, 200 + sizeVariation * 0.7);

        position = {
          x,
          y,
          rotation,
          width,
          height,
          zIndex: 10 + i,
        };

        // Check if position overlaps with existing cards
        const overlaps = positions.some((existingPos) => {
          const dx = position.x - existingPos.x;
          const dy = position.y - existingPos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });

        if (!overlaps || attempts > 50) {
          break;
        }

        attempts++;
      } while (attempts < 100);

      positions.push(position);
    }

    return positions;
  }

  // Global animation state
  let animationState: AnimationState = {
    isGridMode: false,
    flipState: null,
    scrollTrigger: null,
  };

  function applyRandomPositioning() {
    const container = document.getElementById("cards-container");
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;

    if (!container || cards.length === 0) return;

    const containerRect = container.getBoundingClientRect();
    const containerWidth = containerRect.width;
    const containerHeight = Math.max(containerRect.height, window.innerHeight);

    // Generate positions
    const positions = generateCardPositions(
      cards.length,
      containerWidth,
      containerHeight
    );

    // Apply positions to cards
    cards.forEach((card, index) => {
      const position = positions[index];
      if (!position) return;

      // Apply responsive sizing
      const isMobile = window.innerWidth <= 768;
      const isSmallMobile = window.innerWidth <= 480;

      let finalWidth = position.width;
      let finalHeight = position.height;

      if (isSmallMobile) {
        finalWidth = Math.min(finalWidth, 160);
        finalHeight = Math.min(finalHeight, 120);
      } else if (isMobile) {
        finalWidth = Math.min(finalWidth, 200);
        finalHeight = Math.min(finalHeight, 150);
      }

      // Apply styles
      card.style.left = `${position.x}px`;
      card.style.top = `${position.y}px`;
      card.style.width = `${finalWidth}px`;
      card.style.height = `${finalHeight}px`;
      card.style.transform = `rotate(${position.rotation}deg)`;
      card.style.zIndex = position.zIndex.toString();
    });
  }

  function animateToGrid() {
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const gridPlaceholders = document.querySelectorAll(
      ".grid-placeholder"
    ) as NodeListOf<HTMLElement>;
    const textContent = document.getElementById("text-content");
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;

    if (cards.length === 0 || gridPlaceholders.length === 0 || !textContent)
      return;

    // Record the current state for Flip
    const state = Flip.getState([...cards, textContent]);

    // Move cards to grid positions on the LEFT side (target state)
    cards.forEach((card, index) => {
      const placeholder = gridPlaceholders[index];
      if (!placeholder) return;

      const placeholderRect = placeholder.getBoundingClientRect();
      const containerRect = document
        .getElementById("cards-container")!
        .getBoundingClientRect();

      // Calculate position relative to container
      const left = placeholderRect.left - containerRect.left;
      const top = placeholderRect.top - containerRect.top;

      // Apply grid positioning on left side
      card.style.left = `${left}px`;
      card.style.top = `${top}px`;
      card.style.width = `${placeholderRect.width}px`;
      card.style.height = `${placeholderRect.height}px`;
      card.style.transform = "rotate(0deg)";
      card.style.zIndex = "10";
    });

    // Move text to RIGHT side (target state)
    const containerRect = document
      .getElementById("content-container")!
      .getBoundingClientRect();
    const rightSideStart = containerRect.width / 2;
    textContent.style.transform = `translateX(${rightSideStart}px)`;

    // Animate layout transition
    if (!prefersReducedMotion) {
      // Animate cards and text with Flip
      Flip.from(state, {
        duration: 0.6,
        ease: "power2.inOut",
        stagger: 0.02,
        simple: true, // Disables rotation and scale interpolation for smoother transition
      });
    }

    animationState.isGridMode = true;
  }

  function animateToScattered() {
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const textContent = document.getElementById("text-content");
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;

    if (cards.length === 0 || !textContent) return;

    // Record the current state for Flip
    const state = Flip.getState([...cards, textContent]);

    // Apply scattered positioning (back to right side - initial state)
    applyRandomPositioning();

    // Move text back to LEFT side (initial state)
    textContent.style.transform = "translateX(0px)";

    // Animate layout switch back: Cards move to right, Text moves to left
    if (!prefersReducedMotion) {
      // Animate cards and text with Flip
      Flip.from(state, {
        duration: 0.6,
        ease: "power2.inOut",
        stagger: 0.02,
        simple: true, // Disables rotation and scale interpolation for smoother transition
      });
    }

    animationState.isGridMode = false;
  }

  function setupScrollTrigger() {
    const container = document.querySelector(".scattered-gallery-container");
    const splitContainer = document.querySelector("#split-container");
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;

    if (!container || !splitContainer) return;

    // Clean up existing scroll trigger
    if (animationState.scrollTrigger) {
      animationState.scrollTrigger.kill();
    }

    // Main scroll trigger with pinning to keep section in view during transition
    animationState.scrollTrigger = ScrollTrigger.create({
      trigger: container,
      start: "top top",
      end: "+=300vh", // Pin for 1.5 viewport heights of scrolling for smoother transition
      pin: splitContainer, // Pin the split container to keep it in viewport
      pinSpacing: true, // Add spacing after pinned section
      scrub: 1, // Smooth scrubbing tied to scroll position
      onUpdate: (self) => {
        const progress = self.progress;

        // Trigger layout transformation at 50% scroll progress
        if (progress > 0.5 && !animationState.isGridMode) {
          animateToGrid();
        } else if (progress <= 0.5 && animationState.isGridMode) {
          animateToScattered();
        }
      },
      onRefresh: () => {
        // Recalculate positions when ScrollTrigger refreshes (e.g., on resize)
        if (!animationState.isGridMode) {
          applyRandomPositioning();
        }
      },
    });

    // Initial text animation on page load
    if (!prefersReducedMotion) {
      gsap.fromTo(
        "#main-title",
        { opacity: 0, y: 50 },
        { opacity: 1, y: 0, duration: 1, ease: "power2.out" }
      );
      gsap.fromTo(
        "#main-description",
        { opacity: 0, y: 30 },
        { opacity: 1, y: 0, duration: 1, delay: 0.3, ease: "power2.out" }
      );
    } else {
      // Set initial state for reduced motion
      gsap.set(["#main-title", "#main-description"], {
        opacity: 1,
        y: 0,
      });
    }
  }

  function initializeGallery() {
    // Clean up existing ScrollTriggers
    ScrollTrigger.getAll().forEach((trigger) => trigger.kill());

    // Reset animation state
    animationState.isGridMode = false;
    animationState.flipState = null;

    // Ensure text is in initial position (left side)
    const textContent = document.getElementById("text-content");
    if (textContent) {
      textContent.style.transform = "translateX(0px)";
    }

    // Apply initial scattered positioning (right side)
    applyRandomPositioning();

    // Setup scroll-triggered animations with pinning
    setupScrollTrigger();

    // Setup card interactions
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;

    cards.forEach((card, index) => {
      // Add keyboard navigation
      card.setAttribute("tabindex", "0");
      card.setAttribute("role", "button");
      card.setAttribute("aria-label", `Brand card ${index + 1}`);

      // Add click handler for potential interactions
      card.addEventListener("click", () => {
        console.log(`Card ${index + 1} clicked`);
        // Add your click logic here
      });

      // Add keyboard support
      card.addEventListener("keydown", (e: KeyboardEvent) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          (card as HTMLElement).click();
        }
      });

      // Enhanced hover effects (respecting reduced motion)
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;

      if (!prefersReducedMotion) {
        let originalTransform = "";

        card.addEventListener("mouseenter", () => {
          originalTransform = card.style.transform;
          card.style.transform =
            originalTransform + " translateY(-10px) scale(1.05)";
        });

        card.addEventListener("mouseleave", () => {
          card.style.transform = originalTransform;
        });
      }
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeGallery);
  } else {
    initializeGallery();
  }

  // Re-initialize on navigation (for SPA-like behavior)
  document.addEventListener("astro:page-load", initializeGallery);

  // Re-position on resize with proper layout handling
  window.addEventListener("resize", () => {
    clearTimeout((window as any).resizeTimeout);
    (window as any).resizeTimeout = setTimeout(() => {
      const textContent = document.getElementById("text-content");

      if (animationState.isGridMode) {
        // If in grid mode, re-apply grid positioning and text positioning
        const cards = document.querySelectorAll(
          "[data-card]"
        ) as NodeListOf<HTMLElement>;
        const gridPlaceholders = document.querySelectorAll(
          ".grid-placeholder"
        ) as NodeListOf<HTMLElement>;

        // Reposition cards to grid on left side
        cards.forEach((card, index) => {
          const placeholder = gridPlaceholders[index];
          if (!placeholder) return;

          const placeholderRect = placeholder.getBoundingClientRect();
          const containerRect = document
            .getElementById("cards-container")!
            .getBoundingClientRect();

          const left = placeholderRect.left - containerRect.left;
          const top = placeholderRect.top - containerRect.top;

          card.style.left = `${left}px`;
          card.style.top = `${top}px`;
          card.style.width = `${placeholderRect.width}px`;
          card.style.height = `${placeholderRect.height}px`;
        });

        // Reposition text to right side
        if (textContent) {
          const containerRect = document
            .getElementById("content-container")!
            .getBoundingClientRect();
          const rightSideStart = containerRect.width / 2;
          textContent.style.transform = `translateX(${rightSideStart}px)`;
        }
      } else {
        // If in scattered mode, re-apply scattered positioning and reset text
        applyRandomPositioning();

        // Reset text to left side
        if (textContent) {
          textContent.style.transform = "translateX(0px)";
        }
      }

      // Refresh ScrollTrigger to recalculate positions
      ScrollTrigger.refresh();
    }, 250);
  });
</script>
