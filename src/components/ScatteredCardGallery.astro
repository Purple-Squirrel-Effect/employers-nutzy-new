---
export interface Props {
  cards?: Array<{
    id: string;
    image: string;
    alt: string;
    title?: string;
    subtitle?: string;
    backgroundColor?: string;
  }>;
  className?: string;
}

const {
  cards = [
    {
      id: "card-1",
      image: "/api/placeholder/300/200",
      alt: "Brand Card 1",
      title: "gotiket",
      backgroundColor: "bg-blue-600",
    },
    {
      id: "card-2",
      image: "/api/placeholder/280/180",
      alt: "Brand Card 2",
      title: "Rijksen",
      subtitle: "Web Designer",
      backgroundColor: "bg-white",
    },
    {
      id: "card-3",
      image: "/api/placeholder/320/220",
      alt: "Brand Card 3",
      title: "gotiket",
      backgroundColor: "bg-purple-700",
    },
    {
      id: "card-4",
      image: "/api/placeholder/290/190",
      alt: "Brand Card 4",
      title: "Aleksandrs Baskakows",
      backgroundColor: "bg-white",
    },
    {
      id: "card-5",
      image: "/api/placeholder/310/210",
      alt: "Brand Card 5",
      backgroundColor: "bg-blue-900",
    },
    {
      id: "card-6",
      image: "/api/placeholder/300/200",
      alt: "Brand Card 6",
      title: "gotiket",
      backgroundColor: "bg-white",
    },
  ],
  className = "",
} = Astro.props;
---

<!-- ScrollSmoother Wrapper -->
<div id="smooth-wrapper">
  <div id="smooth-content">
    <!-- Main Container with Side-by-Side Layout -->
    <div
      class={`scattered-gallery-container w-full bg-gradient-to-br from-blue-400 via-blue-500 to-blue-600 overflow-hidden ${className}`}
      style="min-height: 100vh;"
    >
      <!-- Background pattern -->
      <div class="absolute inset-0 opacity-10">
        <div class="absolute top-10 left-10 w-4 h-4 bg-white rounded-full">
        </div>
        <div class="absolute top-20 left-32 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute top-32 left-20 w-2 h-2 bg-white rounded-full">
        </div>
        <div class="absolute top-40 left-48 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute top-16 right-20 w-4 h-4 bg-white rounded-full">
        </div>
        <div class="absolute top-36 right-32 w-2 h-2 bg-white rounded-full">
        </div>
        <div class="absolute bottom-20 left-16 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute bottom-32 right-24 w-4 h-4 bg-white rounded-full">
        </div>
      </div>

      <!-- Split Layout Container -->
      <div class="relative w-full h-screen flex" id="split-container">
        <!-- Dynamic Content Container - holds both text and cards -->
        <div class="w-full relative" id="content-container">
          <!-- Text Content - positioned dynamically -->
          <div
            class="absolute inset-0 flex items-center pointer-events-none"
            id="text-container"
          >
            <div
              class="text-content w-1/2 px-8 max-w-lg pointer-events-auto flex items-center justify-center"
              id="text-content"
            >
              <div>
                <h1
                  class="text-4xl md:text-5xl lg:text-6xl font-bold text-white mb-6 drop-shadow-2xl"
                  id="main-title"
                  style="text-shadow: 2px 2px 8px rgba(0,0,0,0.8);"
                >
                  Make your job offers more visible
                </h1>
                <p
                  class="text-lg md:text-xl text-white/90 drop-shadow-lg"
                  id="main-description"
                  style="text-shadow: 1px 1px 4px rgba(0,0,0,0.6);"
                >
                  Transform scattered opportunities into organized, discoverable
                  career paths
                </p>
              </div>
            </div>
          </div>

          <!-- Cards Container - spans full width for positioning flexibility -->
          <div
            class="absolute inset-0 pointer-events-none"
            id="cards-container"
          >
            {
              cards.map((card, index) => (
                <div
                  class={`gallery-card absolute ${card.backgroundColor} rounded-2xl shadow-2xl overflow-hidden transition-all duration-300 hover:scale-105 hover:shadow-3xl hover:z-50 pointer-events-auto`}
                  data-card-id={card.id}
                  data-index={index}
                  data-card
                >
                  {card.image && (
                    <img
                      src={card.image}
                      alt={card.alt}
                      class="w-full h-full object-cover"
                      loading="lazy"
                    />
                  )}

                  {(card.title || card.subtitle) && (
                    <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent flex items-end">
                      <div class="p-4 text-white">
                        {card.title && (
                          <h3 class="text-lg font-bold mb-1">{card.title}</h3>
                        )}
                        {card.subtitle && (
                          <p class="text-sm opacity-90">{card.subtitle}</p>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              ))
            }
          </div>

          <!-- Grid placeholders for target positions -->
          <div class="absolute inset-0 pointer-events-none" id="grid-container">
            <!-- Grid positioned on left side for target state - vertically centered like h-screen flex items-center -->
            <div class="w-1/2 h-full flex items-center justify-center">
              <div
                class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 max-w-2xl w-full px-8"
                id="grid-layout"
              >
                {
                  cards.map((card, index) => (
                    <div
                      class="grid-placeholder bg-transparent rounded-2xl"
                      data-grid-index={index}
                      style="aspect-ratio: 4/3;"
                    />
                  ))
                }
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- End Split Layout Container -->
    </div>
    <!-- End Main Container -->

    <!-- Additional content to demonstrate pinning effect -->
    <section class="bg-gray-100 py-20">
      <div class="container mx-auto px-8 text-center">
        <h2 class="text-4xl font-bold text-gray-800 mb-6">Next Section</h2>
        <p class="text-xl text-gray-600 max-w-2xl mx-auto">
          This section appears after the pinned gallery section. The pinning
          effect keeps the gallery in view while you scroll through the
          transformation.
        </p>
      </div>
    </section>

    <section class="bg-white py-20">
      <div class="container mx-auto px-8 text-center">
        <h2 class="text-4xl font-bold text-gray-800 mb-6">More Content</h2>
        <p class="text-xl text-gray-600 max-w-2xl mx-auto">
          Additional content to provide more scrolling space and demonstrate the
          smooth transition after the pinned section.
        </p>
      </div>
    </section>
  </div>
</div>

<style>
  .scattered-gallery-container {
    position: relative;
    min-height: 100vh;
  }

  /* Split container for pinning */
  #split-container {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
  }

  /* Content container for flexible positioning */
  #content-container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  /* Text content positioning */
  .text-content {
    position: relative;
    transition: transform 0.1s ease-out;
    will-change: transform;
  }

  /* Gallery cards */
  .gallery-card {
    cursor: pointer;
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform, left, top, width, height;
    /* Default sizes that will be overridden by JS */
    width: 280px;
    height: 200px;
  }

  /* Grid container positioning */
  #grid-container {
    pointer-events: none;
  }

  /* Mobile responsive adjustments */
  @media (max-width: 768px) {
    .gallery-card {
      width: 200px;
      height: 150px;
    }

    .text-content {
      padding: 1rem;
    }
  }

  /* Small mobile adjustments */
  @media (max-width: 480px) {
    .gallery-card {
      width: 160px;
      height: 120px;
    }

    .scattered-gallery-container {
      padding: 1rem;
    }

    .text-content h1 {
      font-size: 2rem !important;
    }

    .text-content p {
      font-size: 1rem !important;
    }
  }

  /* Accessibility: Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .gallery-card {
      transition: none !important;
      transform: none !important;
    }

    .gallery-card:hover {
      transform: none !important;
    }

    .text-content {
      transition: none !important;
    }

    /* Disable all GSAP animations for reduced motion */
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* Enhanced shadow for hover state */
  .gallery-card:hover {
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
  }

  /* Focus styles for accessibility */
  .gallery-card:focus {
    outline: 2px solid rgba(255, 255, 255, 0.8);
    outline-offset: 4px;
  }

  /* Smooth performance optimizations */
  .gallery-card,
  .text-content {
    transform: translateZ(0); /* Force hardware acceleration */
  }
</style>

<script>
  import { gsap } from "gsap";
  import { Flip } from "gsap/Flip";
  import { ScrollSmoother } from "gsap/ScrollSmoother";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  // Register GSAP plugins
  gsap.registerPlugin(Flip, ScrollTrigger, ScrollSmoother);

  interface CardPosition {
    x: number;
    y: number;
    rotation: number;
    width: number;
    height: number;
    zIndex: number;
  }

  interface AnimationState {
    scatteredPositions: CardPosition[];
    gridPositions: CardPosition[];
    currentProgress: number;
    isAnimating: boolean;
    animationFrame: number | null;
    scrollStart: number;
    scrollEnd: number;
  }

  // Seeded random number generator for consistent but random-looking layout
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  function generateCardPositions(
    cardCount: number,
    containerWidth: number,
    containerHeight: number
  ): CardPosition[] {
    const positions: CardPosition[] = [];
    const padding = 50; // Minimum distance from edges
    const minDistance = 100; // Minimum distance between card centers

    for (let i = 0; i < cardCount; i++) {
      let attempts = 0;
      let position: CardPosition;

      do {
        // Use index as seed for consistent positioning across reloads
        const seedX = i * 123 + attempts * 7;
        const seedY = i * 456 + attempts * 13;
        const seedRot = i * 789 + attempts * 19;
        const seedSize = i * 321 + attempts * 11;

        // Generate random position - constrain to right half of container (initial state)
        const rightHalfStart = containerWidth / 2;
        const rightHalfWidth = containerWidth / 2;
        const x =
          rightHalfStart +
          padding +
          seededRandom(seedX) * (rightHalfWidth - padding * 2 - 300);
        const y =
          padding + seededRandom(seedY) * (containerHeight - padding * 2 - 250);

        // Random rotation between -20 and 20 degrees
        const rotation = (seededRandom(seedRot) - 0.5) * 40;

        // Slight size variation
        const sizeVariation = seededRandom(seedSize) * 40 - 20;
        const width = Math.max(200, 280 + sizeVariation);
        const height = Math.max(150, 200 + sizeVariation * 0.7);

        position = {
          x,
          y,
          rotation,
          width,
          height,
          zIndex: 10 + i,
        };

        // Check if position overlaps with existing cards
        const overlaps = positions.some((existingPos) => {
          const dx = position.x - existingPos.x;
          const dy = position.y - existingPos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });

        if (!overlaps || attempts > 50) {
          break;
        }

        attempts++;
      } while (attempts < 100);

      positions.push(position);
    }

    return positions;
  }

  // Global animation state
  let animationState: AnimationState = {
    scatteredPositions: [],
    gridPositions: [],
    currentProgress: 0,
    isAnimating: false,
    animationFrame: null,
    scrollStart: 0,
    scrollEnd: 0,
  };

  function calculateScatteredPositions(): CardPosition[] {
    const container = document.getElementById("cards-container");
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;

    if (!container || cards.length === 0) return [];

    const containerRect = container.getBoundingClientRect();
    const containerWidth = containerRect.width;
    const containerHeight = Math.max(containerRect.height, window.innerHeight);

    // Generate positions
    return generateCardPositions(cards.length, containerWidth, containerHeight);
  }

  function calculateGridPositions(): CardPosition[] {
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const gridPlaceholders = document.querySelectorAll(
      ".grid-placeholder"
    ) as NodeListOf<HTMLElement>;

    if (cards.length === 0 || gridPlaceholders.length === 0) return [];

    const positions: CardPosition[] = [];
    const containerRect = document
      .getElementById("cards-container")!
      .getBoundingClientRect();

    cards.forEach((card, index) => {
      const placeholder = gridPlaceholders[index];
      if (!placeholder) return;

      const placeholderRect = placeholder.getBoundingClientRect();

      // Calculate position relative to container
      const left = placeholderRect.left - containerRect.left;
      const top = placeholderRect.top - containerRect.top;

      positions.push({
        x: left,
        y: top,
        width: placeholderRect.width,
        height: placeholderRect.height,
        rotation: 0,
        zIndex: 10,
      });
    });

    return positions;
  }

  // Create GSAP timeline for scroll-controlled animation
  function createScrollTimeline(): gsap.core.Timeline {
    const timeline = gsap.timeline({ paused: true });
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const textContent = document.getElementById("text-content");

    if (cards.length === 0 || !textContent) return timeline;

    // Calculate positions
    const scatteredPositions = calculateScatteredPositions();
    const gridPositions = calculateGridPositions();

    // Store positions in animation state
    animationState.scatteredPositions = scatteredPositions;
    animationState.gridPositions = gridPositions;

    // Set initial scattered positions
    cards.forEach((card, index) => {
      const pos = scatteredPositions[index];
      if (!pos) return;

      // Apply responsive sizing
      const isMobile = window.innerWidth <= 768;
      const isSmallMobile = window.innerWidth <= 480;
      let finalWidth = pos.width;
      let finalHeight = pos.height;

      if (isSmallMobile) {
        finalWidth = Math.min(finalWidth, 160);
        finalHeight = Math.min(finalHeight, 120);
      } else if (isMobile) {
        finalWidth = Math.min(finalWidth, 200);
        finalHeight = Math.min(finalHeight, 150);
      }

      gsap.set(card, {
        left: pos.x,
        top: pos.y,
        width: finalWidth,
        height: finalHeight,
        rotation: pos.rotation,
        zIndex: pos.zIndex,
      });
    });

    // Set initial text position (left side)
    gsap.set(textContent, { x: 0 });

    // Create timeline animations
    cards.forEach((card, index) => {
      const startPos = scatteredPositions[index];
      const endPos = gridPositions[index];
      if (!startPos || !endPos) return;

      // Apply responsive sizing for end position
      const isMobile = window.innerWidth <= 768;
      const isSmallMobile = window.innerWidth <= 480;
      let finalWidth = endPos.width;
      let finalHeight = endPos.height;

      if (isSmallMobile) {
        finalWidth = Math.min(finalWidth, 160);
        finalHeight = Math.min(finalHeight, 120);
      } else if (isMobile) {
        finalWidth = Math.min(finalWidth, 200);
        finalHeight = Math.min(finalHeight, 150);
      }

      // Animate each card from scattered to grid position
      timeline.to(
        card,
        {
          left: endPos.x,
          top: endPos.y,
          width: finalWidth,
          height: finalHeight,
          rotation: endPos.rotation,
          zIndex: endPos.zIndex,
          duration: 1,
          ease: "power2.inOut",
        },
        0
      ); // All cards animate simultaneously
    });

    // Animate text from left to right
    const containerRect = document
      .getElementById("content-container")!
      .getBoundingClientRect();
    const rightSideStart = containerRect.width / 2;

    timeline.to(
      textContent,
      {
        x: rightSideStart,
        duration: 1,
        ease: "power2.inOut",
      },
      0
    ); // Text animates with cards

    return timeline;
  }

  // Global timeline variable
  let scrollTimeline: gsap.core.Timeline | null = null;

  function setupScrollAnimation() {
    const container = document.querySelector(".scattered-gallery-container");
    const splitContainer = document.querySelector("#split-container");
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;

    if (!container || !splitContainer || prefersReducedMotion) {
      // Set initial state for reduced motion
      gsap.set(["#main-title", "#main-description"], {
        opacity: 1,
        y: 0,
      });
      return;
    }

    // Initialize ScrollSmoother for smooth scrolling
    ScrollSmoother.create({
      wrapper: "#smooth-wrapper",
      content: "#smooth-content",
      smooth: 1.5, // Smooth scrolling intensity
      effects: true, // Enable data-speed effects
    });

    // Create the timeline
    scrollTimeline = createScrollTimeline();

    // Setup ScrollTrigger with pinning and scrub
    ScrollTrigger.create({
      trigger: container,
      start: "top top",
      end: "+=400vh", // Pin for 4 viewport heights of scrolling (longer duration)
      pin: splitContainer, // Pin the split container to keep it in viewport
      pinSpacing: true, // Add spacing after pinned section
      scrub: 1, // Smooth scrubbing tied to scroll position
      onUpdate: (self) => {
        if (scrollTimeline) {
          // Map scroll progress to animation progress with extended hold at end
          // Animation completes at 50% scroll, then holds the final state
          let animationProgress = Math.min(self.progress * 2, 1);

          scrollTimeline.progress(animationProgress);
          animationState.currentProgress = animationProgress;
        }
      },
      onRefresh: () => {
        // Recalculate positions when ScrollTrigger refreshes (e.g., on resize)
        if (scrollTimeline) {
          scrollTimeline.kill();
          scrollTimeline = createScrollTimeline();
          scrollTimeline.progress(animationState.currentProgress);
        }
      },
    });

    // Initial text animation on page load
    gsap.fromTo(
      "#main-title",
      { opacity: 0, y: 50 },
      { opacity: 1, y: 0, duration: 1, ease: "power2.out" }
    );
    gsap.fromTo(
      "#main-description",
      { opacity: 0, y: 30 },
      { opacity: 1, y: 0, duration: 1, delay: 0.3, ease: "power2.out" }
    );
  }

  function initializeGallery() {
    // Clean up existing ScrollTriggers
    ScrollTrigger.getAll().forEach((trigger) => trigger.kill());

    if (animationState.animationFrame) {
      cancelAnimationFrame(animationState.animationFrame);
    }

    // Reset animation state
    animationState.currentProgress = 0;
    animationState.isAnimating = false;
    animationState.scatteredPositions = [];
    animationState.gridPositions = [];

    // Setup scroll-controlled animations with ScrollTrigger
    setupScrollAnimation();

    // Setup card interactions
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;

    cards.forEach((card, index) => {
      // Add keyboard navigation
      card.setAttribute("tabindex", "0");
      card.setAttribute("role", "button");
      card.setAttribute("aria-label", `Brand card ${index + 1}`);

      // Add click handler for potential interactions
      card.addEventListener("click", () => {
        console.log(`Card ${index + 1} clicked`);
        // Add your click logic here
      });

      // Add keyboard support
      card.addEventListener("keydown", (e: KeyboardEvent) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          (card as HTMLElement).click();
        }
      });

      // Enhanced hover effects (respecting reduced motion)
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;

      if (!prefersReducedMotion) {
        let originalTransform = "";

        card.addEventListener("mouseenter", () => {
          originalTransform = card.style.transform;
          card.style.transform =
            originalTransform + " translateY(-10px) scale(1.05)";
        });

        card.addEventListener("mouseleave", () => {
          card.style.transform = originalTransform;
        });
      }
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeGallery);
  } else {
    initializeGallery();
  }

  // Re-initialize on navigation (for SPA-like behavior)
  document.addEventListener("astro:page-load", initializeGallery);

  // Re-position on resize with proper layout handling
  window.addEventListener("resize", () => {
    clearTimeout((window as any).resizeTimeout);
    (window as any).resizeTimeout = setTimeout(() => {
      // Refresh ScrollTrigger to recalculate positions and pinning
      ScrollTrigger.refresh();
    }, 250);
  });
</script>
