---
import AboutSection1 from "./AboutSection1.astro";
import LogoScrollSection from "./LogoScrollSection.astro";
import NutzyStatsSection from "./NutzyStatsSection.astro";
import ContactSection from "./ContactSection.astro";
import Footer from "./Footer.astro";
import Section from "./Section.astro";
import IPhoneMockup from "./IPhoneMockup.astro";
import ScatteredCards from "./ScatteredCards.astro";
import FanpageSection from "./FanpageSection.astro";
import type { Card } from "./ScatteredCards.astro";

export interface Props {
  cards?: Card[];
  className?: string;
}

const {
  cards = [
    {
      id: "card-1",
      wireframe: "/img/wireframes/job-board-wireframe.svg",
      alt: "Job Board Platform",
      title: "JobFind",
      websiteType: "job-board",
      backgroundColor: "bg-primary-500",
    },
    {
      id: "card-2",
      wireframe: "/img/wireframes/linkedin-wireframe.svg",
      alt: "Professional Network",
      title: "CareerNet",
      subtitle: "Professional Platform",
      websiteType: "professional-network",
      backgroundColor: "bg-white",
    },
    {
      id: "card-3",
      wireframe: "/img/wireframes/job-detail-wireframe.svg",
      alt: "Job Detail Page",
      title: "Position View",
      websiteType: "job-detail",
      backgroundColor: "bg-primary-900",
    },
    {
      id: "card-4",
      wireframe: "/img/wireframes/recruitment-dashboard-wireframe.svg",
      alt: "Recruitment Dashboard",
      title: "Talent Hub",
      websiteType: "recruitment-dashboard",
      backgroundColor: "bg-white",
    },
    {
      id: "card-5",
      wireframe: "/img/wireframes/job-board-wireframe.svg",
      alt: "Alternative Job Board",
      title: "TechJobs",
      websiteType: "job-board",
      backgroundColor: "bg-primary-900",
    },
    {
      id: "card-6",
      wireframe: "/img/wireframes/linkedin-wireframe.svg",
      alt: "Professional Platform",
      title: "NetworkPro",
      websiteType: "professional-network",
      backgroundColor: "bg-white",
    },
  ],
  className = "",
} = Astro.props;
---

<!-- ScrollSmoother Wrapper -->
<div id="smooth-wrapper">
  <div id="smooth-content">
    <!-- Main Container with Side-by-Side Layout -->
    <div
      class={`scattered-gallery-container overflow-hidden w-full bg-white relative ${className}`}
      style="min-height: 100vh;"
    >
      <img
        src="/svg/particle/rocket.svg"
        alt="Rocket illustration"
        class="absolute h-screen w-screen top-0 left opacity-40 z-0"
        loading="lazy"
      />
      <!-- Background pattern - initially hidden -->
      <div class="absolute inset-0 opacity-0">
        <div class="absolute top-10 left-10 w-4 h-4 bg-white rounded-full">
        </div>
        <div class="absolute top-20 left-32 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute top-32 left-20 w-2 h-2 bg-white rounded-full">
        </div>
        <div class="absolute top-40 left-48 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute top-16 right-20 w-4 h-4 bg-white rounded-full">
        </div>
        <div class="absolute top-36 right-32 w-2 h-2 bg-white rounded-full">
        </div>
        <div class="absolute bottom-20 left-16 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute bottom-32 right-24 w-4 h-4 bg-white rounded-full">
        </div>
      </div>

      <!-- Split Layout Container -->
      <div class="relative w-full h-screen flex" id="split-container">
        <!-- Dynamic Content Container - holds both text and cards -->
        <div class="w-full relative" id="content-container">
          <!-- Text Content - positioned dynamically -->
          <div
            class="absolute inset-0 flex items-center pointer-events-none"
            id="text-container"
          >
            <div
              class="text-content w-full lg:w-1/2 px-8 max-w-lg pointer-events-auto flex items-center justify-center"
              id="text-content"
            >
              <div class="relative">
                <!-- First title - initial state -->
                <h1
                  class="text-4xl md:text-5xl lg:text-8xl font-bold text-black mb-6 drop-shadow-2xl absolute inset-0"
                  id="main-title"
                >
                  Moeite met <br />
                  <span class="text-purple-900">Gen Z</span>
                  bereiken?
                </h1>
                <!-- Second title - target state -->
                <h1
                  class="text-4xl md:text-5xl lg:text-8xl font-bold text-black mb-6 drop-shadow-2xl absolute inset-0 opacity-0"
                  id="second-title"
                >
                  Op <span class="text-purple-900">NUTZY</span>
                  valt je vacature op
                </h1>
                <!-- Invisible spacer to maintain layout height -->
                <h1
                  class="text-4xl md:text-5xl lg:text-8xl font-bold text-black mb-6 opacity-0 pointer-events-none"
                  aria-hidden="true"
                >
                  Moeite met <br />
                  Gen Z bereiken?
                </h1>
              </div>
            </div>
          </div>

          <!-- Cards Container - spans full width for positioning flexibility -->
          <div
            class="absolute top-32 inset-0 pointer-events-none"
            id="cards-container"
          >
            <ScatteredCards
              cards={cards}
              staticPositions={true}
              containerHeight="100%"
              containerWidth="100%"
              className="pointer-events-auto"
            />
          </div>

          <!-- iPhone Mockup for target position -->
          <div
            class="absolute inset-0 pointer-events-none"
            id="single-card-container"
          >
            <!-- iPhone positioned on left side for target state - vertically centered like h-screen flex items-center -->
            <div class="w-1/2 h-full flex items-center justify-center">
              <div class="flex items-center justify-center w-full px-8">
                <!-- iPhone Mockup Container - invisible initially, used for positioning -->
                <div
                  class="single-card-placeholder relative"
                  data-single-card-index="0"
                  style="opacity: 0;"
                >
                  <IPhoneMockup
                    videoSrc="/videos/product.mp4"
                    videoPoster="/videos/product.mp4"
                    videoAlt="iPhone mockup showing Nutzy product video"
                    width="min(330px, 70vw)"
                    height="min(600px, 85vh)"
                    muted={true}
                    loop={true}
                    fallbackTitle="Product Demo"
                    fallbackDescription="Ontdek Nutzy's platform"
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- End Split Layout Container -->
    </div>

    <!-- End Main Container -->
    <AboutSection1 />
    <FanpageSection />
    <LogoScrollSection />
    <NutzyStatsSection />
    <ContactSection />
    <Footer />
  </div>
</div>

<style>
  .scattered-gallery-container {
    position: relative;
    min-height: 100vh;
    transition: background-color 0.3s ease-out;
    will-change: background-color;
  }

  /* Split container for pinning */
  #split-container {
    position: relative;
    width: 100%;
    height: 100vh;
  }

  /* Content container for flexible positioning */
  #content-container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  /* Text content positioning */
  .text-content {
    position: relative;
    transition: transform 0.1s ease-out;
    will-change: transform;
  }

  /* Text elements with smooth color transitions */
  .text-content h1,
  .text-content p {
    transition: color 0.3s ease-out;
    will-change: color;
  }

  /* Single card container positioning */
  #single-card-container {
    pointer-events: none;
  }

  /* Mobile responsive adjustments for vertical layout */
  @media (max-width: 768px) {
    .text-content {
      padding: 1rem;
      /* Allow for mobile positioning via GSAP */
      position: absolute !important;
      width: 100% !important;
      max-width: none !important;
      /* Remove any default positioning that might interfere */
      left: auto !important;
      right: auto !important;
      transform: none !important;
      text-align: center !important;
    }

    /* Mobile-specific text positioning */
    #text-container {
      position: absolute !important;
      width: 100% !important;
      height: 100% !important;
      /* Override desktop flex positioning */
      display: block !important;
      align-items: unset !important;
      /* Remove any default positioning */
      top: 0 !important;
      left: 0 !important;
    }

    /* Mobile iPhone mockup positioning - centered at top */
    .single-card-placeholder {
      max-width: 280px !important;
      max-height: 500px !important;
      margin: 0 auto !important;
    }

    /* Override desktop side-by-side layout for mobile */
    #single-card-container {
      width: 100% !important;
      display: flex !important;
      justify-content: center !important;
      align-items: flex-start !important;
      padding-top: 10vh !important;
    }

    #single-card-container .w-1\/2 {
      width: 100% !important;
    }

    /* Override desktop flex layout for mobile */
    #split-container {
      display: block !important;
      height: 100vh !important;
    }

    #content-container {
      position: relative !important;
      height: 100vh !important;
    }

    /* Mobile text sizing adjustments */
    .text-content h1 {
      font-size: 2.5rem !important;
      line-height: 1.1 !important;
      margin-bottom: 1rem !important;
      text-align: center !important;
    }

    /* Cards container for mobile - allow full height for scattered positioning */
    #cards-container {
      top: 0 !important;
      height: 100vh !important;
    }

    /* Ensure proper stacking for mobile */
    #single-card-container {
      z-index: 20 !important;
    }

    #text-container {
      z-index: 30 !important;
    }

    #cards-container {
      z-index: 10 !important;
    }
  }

  /* Small mobile adjustments */
  @media (max-width: 480px) {
    .scattered-gallery-container {
      padding: 1rem;
    }

    .text-content h1 {
      font-size: 2rem !important;
    }

    .text-content p {
      font-size: 1rem !important;
    }
  }

  /* Accessibility: Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .text-content {
      transition: none !important;
    }

    /* Disable all GSAP animations for reduced motion */
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* Smooth performance optimizations */
  .text-content {
    transform: translateZ(0); /* Force hardware acceleration */
  }

  /* Logo container styles */
  .logo-container {
    position: absolute;
    top: 1.5rem;
    left: 1.5rem;
    z-index: 50;
    transition: all 0.3s ease-out;
    will-change: color, transform;
  }

  /* Logo responsive adjustments */
  @media (max-width: 640px) {
    .logo-container {
      top: 1rem;
      left: 1rem;
    }

    .logo-container .text-xl {
      font-size: 1.125rem;
    }
  }

  /* Logo color transitions for scroll animations */
  .logo-container a span {
    transition: color 0.3s ease-out;
    will-change: color;
  }

  /* Ensure logo stays above all other elements */
  .logo-container {
    pointer-events: auto;
  }

  /* Logo accessibility improvements */
  .logo-container a:focus {
    outline: 2px solid rgba(255, 255, 255, 0.8);
    outline-offset: 4px;
    border-radius: 0.75rem;
  }

  /* Logo hover effects */
  .logo-container a:hover .text-primary-900 {
    color: var(--color-primary-500);
  }
</style>

<script>
  import { gsap } from "gsap";
  import { Flip } from "gsap/Flip";
  import { ScrollSmoother } from "gsap/ScrollSmoother";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  // Register GSAP plugins
  gsap.registerPlugin(Flip, ScrollTrigger, ScrollSmoother);

  interface CardPosition {
    x: number;
    y: number;
    rotation: number;
    width: number;
    height: number;
    zIndex: number;
  }

  interface AnimationState {
    scatteredPositions: CardPosition[];
    singleCardPositions: CardPosition[];
    currentProgress: number;
    isAnimating: boolean;
    animationFrame: number | null;
    scrollStart: number;
    scrollEnd: number;
  }

  // Seeded random number generator for consistent but random-looking layout
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  function generateCardPositions(
    cardCount: number,
    containerWidth: number,
    containerHeight: number,
    isMobile: boolean = false
  ): CardPosition[] {
    const positions: CardPosition[] = [];
    const padding = 50; // Minimum distance from edges
    const minDistance = 100; // Minimum distance between card centers

    for (let i = 0; i < cardCount; i++) {
      let attempts = 0;
      let position: CardPosition;

      do {
        // Use index as seed for consistent positioning across reloads
        const seedX = i * 123 + attempts * 7;
        const seedY = i * 456 + attempts * 13;
        const seedRot = i * 789 + attempts * 19;
        const seedSize = i * 321 + attempts * 11;

        let x: number, y: number;

        if (isMobile) {
          // Mobile: scatter cards across full width, in middle section (avoiding text areas)
          const mobileTopOffset = containerHeight * 0.3; // Start cards below initial text area
          const mobileBottomOffset = containerHeight * 0.2; // Leave space for final text area
          const availableHeight =
            containerHeight - mobileTopOffset - mobileBottomOffset;
          x =
            padding +
            seededRandom(seedX) * (containerWidth - padding * 2 - 180);
          y = mobileTopOffset + seededRandom(seedY) * availableHeight;
        } else {
          // Desktop: constrain to right half of container (initial state)
          const rightHalfStart = containerWidth / 2;
          const rightHalfWidth = containerWidth / 2;
          x =
            rightHalfStart +
            padding +
            seededRandom(seedX) * (rightHalfWidth - padding * 2 - 300);
          y =
            padding +
            seededRandom(seedY) * (containerHeight - padding * 2 - 250);
        }

        // Random rotation between -20 and 20 degrees
        const rotation = (seededRandom(seedRot) - 0.5) * 40;

        // Slight size variation
        const sizeVariation = seededRandom(seedSize) * 40 - 20;
        const width = Math.max(200, 280 + sizeVariation);
        const height = Math.max(150, 200 + sizeVariation * 0.7);

        position = {
          x,
          y,
          rotation,
          width,
          height,
          zIndex: 10 + i,
        };

        // Check if position overlaps with existing cards
        const overlaps = positions.some((existingPos) => {
          const dx = position.x - existingPos.x;
          const dy = position.y - existingPos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });

        if (!overlaps || attempts > 50) {
          break;
        }

        attempts++;
      } while (attempts < 100);

      positions.push(position);
    }

    return positions;
  }

  // Global animation state
  let animationState: AnimationState = {
    scatteredPositions: [],
    singleCardPositions: [],
    currentProgress: 0,
    isAnimating: false,
    animationFrame: null,
    scrollStart: 0,
    scrollEnd: 0,
  };

  function calculateScatteredPositions(
    isMobile: boolean = false
  ): CardPosition[] {
    const container = document.getElementById("cards-container");
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;

    if (!container || cards.length === 0) return [];

    const containerRect = container.getBoundingClientRect();
    const containerWidth = containerRect.width;
    const containerHeight = Math.max(containerRect.height, window.innerHeight);

    // Generate positions with mobile flag
    return generateCardPositions(
      cards.length,
      containerWidth,
      containerHeight,
      isMobile
    );
  }

  function calculateSingleCardPositions(
    isMobile: boolean = false
  ): CardPosition[] {
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const singleCardPlaceholder = document.querySelector(
      ".single-card-placeholder"
    ) as HTMLElement;

    if (cards.length === 0 || !singleCardPlaceholder) return [];

    const positions: CardPosition[] = [];
    const containerRect = document
      .getElementById("cards-container")!
      .getBoundingClientRect();

    let left: number, top: number, width: number, height: number;

    if (isMobile) {
      // Mobile: Professional sizing - iPhone positioned at top center
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const mobileWidth = Math.min(viewportWidth * 0.7, 300); // 70% of viewport width, max 300px
      const mobileHeight = Math.min(mobileWidth * 1.8, viewportHeight * 0.45); // Maintain iPhone aspect ratio, max 45% viewport height
      left = (viewportWidth - mobileWidth) / 2;
      top = viewportHeight * 0.1; // 10% from top for compact positioning
      width = mobileWidth;
      height = mobileHeight;
    } else {
      // Desktop: Use existing placeholder positioning but make it smaller
      const placeholderRect = singleCardPlaceholder.getBoundingClientRect();
      left = placeholderRect.left - containerRect.left;
      top = placeholderRect.top - containerRect.top;
      // Make desktop mockup smaller - 80% of original size
      width = placeholderRect.width * 0.8;
      height = placeholderRect.height * 0.8;
      // Adjust position to keep it centered after size reduction
      left += (placeholderRect.width - width) / 2;
      top += (placeholderRect.height - height) / 2;
    }

    // Create position for the first card (which will be the prominent one)
    const prominentCardPosition: CardPosition = {
      x: left,
      y: top,
      width: width,
      height: height,
      rotation: 0,
      zIndex: 20, // Higher z-index for prominence
    };

    // For the first card, use the prominent position
    positions.push(prominentCardPosition);

    // For all other cards, position them off-screen or make them invisible
    // by positioning them at the same location but with opacity 0
    cards.forEach((_, index) => {
      if (index > 0) {
        positions.push({
          x: left,
          y: top,
          width: width,
          height: height,
          rotation: 0,
          zIndex: 1, // Lower z-index, will be hidden
        });
      }
    });

    return positions;
  }

  // Create mobile GSAP timeline for vertical scroll-controlled animation
  function createMobileScrollTimeline(): gsap.core.Timeline {
    const timeline = gsap.timeline({ paused: true });
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const textContent = document.getElementById("text-content");
    const mainTitle = document.getElementById("main-title");
    const secondTitle = document.getElementById("second-title");
    const container = document.querySelector(
      ".scattered-gallery-container"
    ) as HTMLElement;

    console.log("Creating mobile vertical timeline");
    console.log(`Found ${cards.length} cards`);

    if (
      cards.length === 0 ||
      !textContent ||
      !mainTitle ||
      !secondTitle ||
      !container
    ) {
      console.warn("Missing required elements for mobile timeline");
      return timeline;
    }

    // Calculate mobile positions
    const scatteredPositions = calculateScatteredPositions(true);
    const singleCardPositions = calculateSingleCardPositions(true);

    // Store positions in animation state
    animationState.scatteredPositions = scatteredPositions;
    animationState.singleCardPositions = singleCardPositions;

    // Set initial scattered positions for mobile (cards in middle area)
    cards.forEach((card, index) => {
      const pos = scatteredPositions[index];
      if (!pos) return;

      gsap.set(card, {
        left: pos.x,
        top: pos.y,
        width: pos.width,
        height: pos.height,
        rotation: pos.rotation,
        zIndex: pos.zIndex,
        opacity: 1,
      });
    });

    // Set initial state for iPhone mockup (hidden)
    const mockupContainer = document.querySelector(
      ".single-card-placeholder"
    ) as HTMLElement;
    if (mockupContainer) {
      gsap.set(mockupContainer, {
        opacity: 0,
        scale: 0.8,
      });
    }

    // Set initial text position for mobile - start at top center
    gsap.set(textContent, {
      x: "50%",
      y: 0,
      xPercent: -50, // This centers the element horizontally
      top: "20%", // Start at top 20% of screen
      position: "absolute",
      width: "100%",
      textAlign: "center",
    });
    gsap.set(mainTitle, { opacity: 1 });
    gsap.set(secondTitle, { opacity: 0 });

    // Set initial background state
    gsap.set(container, { backgroundColor: "#bd7ef2" });

    // Mobile timeline animations - vertical layout
    console.log("Setting up mobile timeline phases...");

    // Phase 1: Fade out scattered cards (0-0.6s)
    cards.forEach((card, index) => {
      timeline.to(
        card,
        {
          opacity: 0,
          scale: 0.8,
          duration: 0.6,
          ease: "power2.inOut",
        },
        0
      );
    });

    // Phase 2: Move text from top to bottom (0.2-1.0s)
    timeline.to(
      textContent,
      {
        top: "85%", // Move to 85% of screen (5% less than 90%)
        duration: 0.8,
        ease: "power2.inOut",
      },
      0.2
    );

    // Phase 3: Show iPhone mockup at top (0.4-1.2s)
    if (mockupContainer) {
      timeline.to(
        mockupContainer,
        {
          opacity: 1,
          scale: 1,
          duration: 0.8,
          ease: "power2.out",
        },
        0.4
      );
    }

    // Phase 4: Background transition (0-1.0s)
    timeline.to(
      container,
      {
        backgroundColor: "#25B4B3",
        duration: 1,
        ease: "power2.inOut",
      },
      0
    );

    // Phase 5: Text transition (0.3-0.9s) - using fromTo for better reversibility
    timeline.fromTo(
      mainTitle,
      { opacity: 1 },
      {
        opacity: 0,
        duration: 0.4,
        ease: "power2.inOut",
      },
      0.3
    );

    timeline.fromTo(
      secondTitle,
      { opacity: 0 },
      {
        opacity: 1,
        duration: 0.4,
        ease: "power2.inOut",
      },
      0.5
    );

    console.log("Mobile timeline created successfully");
    return timeline;
  }

  // Create desktop GSAP timeline for scroll-controlled animation
  function createDesktopScrollTimeline(): gsap.core.Timeline {
    const timeline = gsap.timeline({ paused: true });
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const textContent = document.getElementById("text-content");
    const mainTitle = document.getElementById("main-title");
    const secondTitle = document.getElementById("second-title");
    const mainDescription = document.getElementById("main-description");
    const container = document.querySelector(
      ".scattered-gallery-container"
    ) as HTMLElement;
    const backgroundPattern = container?.querySelector(
      ".absolute.inset-0.opacity-5"
    ) as HTMLElement;

    if (
      cards.length === 0 ||
      !textContent ||
      !mainTitle ||
      !secondTitle ||
      !container
    )
      return timeline;

    // Calculate desktop positions
    const scatteredPositions = calculateScatteredPositions(false);
    const singleCardPositions = calculateSingleCardPositions(false);

    // Store positions in animation state
    animationState.scatteredPositions = scatteredPositions;
    animationState.singleCardPositions = singleCardPositions;

    // Set initial scattered positions for desktop
    cards.forEach((card, index) => {
      const pos = scatteredPositions[index];
      if (!pos) return;

      gsap.set(card, {
        left: pos.x,
        top: pos.y,
        width: pos.width,
        height: pos.height,
        rotation: pos.rotation,
        zIndex: pos.zIndex,
        opacity: 1,
      });
    });

    // Set initial state for iPhone mockup (hidden and scaled down)
    const mockupContainer = document.querySelector(
      ".single-card-placeholder"
    ) as HTMLElement;
    if (mockupContainer) {
      gsap.set(mockupContainer, {
        opacity: 0,
        scale: 0.8,
      });
    }

    // Set initial text position (left side) and title states
    gsap.set(textContent, { x: 0 });
    gsap.set(mainTitle, { opacity: 1 });
    gsap.set(secondTitle, { opacity: 0 });

    // Set initial background state
    gsap.set(container, { backgroundColor: "#bd7ef2" });
    if (backgroundPattern) {
      gsap.set(backgroundPattern, { opacity: 0 });
    }

    // Set initial logo state (purple color for white background)
    const initialLogoText = document.querySelector(".logo-container span");
    if (initialLogoText) {
      gsap.set(initialLogoText, { color: "#581c87" }); // Initial purple color
    }

    // Desktop timeline animations - fade out all cards and show iPhone mockup
    cards.forEach((card, index) => {
      timeline.to(
        card,
        {
          opacity: 0,
          scale: 0.8,
          duration: 0.8,
          ease: "power2.inOut",
        },
        0
      );
    });

    // Show iPhone mockup after cards fade out
    if (mockupContainer) {
      timeline.to(
        mockupContainer,
        {
          opacity: 1,
          scale: 1,
          duration: 0.8,
          ease: "power2.out",
        },
        0.4
      );
    }

    // Animate text from left to right
    const containerRect = document
      .getElementById("content-container")!
      .getBoundingClientRect();
    const rightSideStart = containerRect.width / 2;

    timeline.to(
      textContent,
      {
        x: rightSideStart,
        duration: 1,
        ease: "power2.inOut",
      },
      0
    );

    // Background transition
    timeline.to(
      container,
      {
        backgroundColor: "#25B4B3",
        duration: 1,
        ease: "power2.inOut",
      },
      0
    );

    // Fade out background pattern during transition
    if (backgroundPattern) {
      timeline.to(
        backgroundPattern,
        {
          opacity: 0,
          duration: 0.8,
          ease: "power2.inOut",
        },
        0.1
      );
    }

    // Change text colors to white for better contrast
    const textElements = [mainTitle, secondTitle];
    if (mainDescription) {
      textElements.push(mainDescription);
    }

    timeline.to(
      textElements,
      {
        color: "#ffffff",
        duration: 0.8,
        ease: "power2.inOut",
      },
      0.2
    );

    // Change logo text color to white for better contrast
    const animationLogoText = document.querySelector(".logo-container span");
    if (animationLogoText) {
      timeline.to(
        animationLogoText,
        {
          color: "#ffffff",
          duration: 0.8,
          ease: "power2.inOut",
        },
        0.2
      );
    }

    // Text transition animation - fade out first title and fade in second title
    timeline.to(
      mainTitle,
      {
        opacity: 0,
        duration: 0.4,
        ease: "power2.inOut",
      },
      0.3
    );

    timeline.to(
      secondTitle,
      {
        opacity: 1,
        duration: 0.4,
        ease: "power2.inOut",
      },
      0.5
    );

    return timeline;
  }

  // Global timeline variable
  let scrollTimeline: gsap.core.Timeline | null = null;

  function setupScrollAnimation() {
    const container = document.querySelector(".scattered-gallery-container");
    const splitContainer = document.querySelector("#split-container");
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;

    if (!container || !splitContainer || prefersReducedMotion) {
      // Set initial state for reduced motion - show first title only
      gsap.set("#main-title", { opacity: 1, y: 0, color: "#000000" });
      gsap.set("#second-title", { opacity: 0, y: 0, color: "#000000" });
      gsap.set("#main-description", { opacity: 1, y: 0, color: "#000000" });

      // Set initial logo state for reduced motion
      const reducedMotionLogoText = document.querySelector(
        ".logo-container span"
      );
      if (reducedMotionLogoText) {
        gsap.set(reducedMotionLogoText, { color: "#581c87" }); // Keep original purple color
      }
      return;
    }

    // Detect mobile vs desktop
    const isMobile = window.innerWidth <= 768;
    console.log(
      `Setting up ${isMobile ? "mobile" : "desktop"} scroll animation`
    );
    console.log(
      `Window dimensions: ${window.innerWidth}x${window.innerHeight}`
    );

    // Create appropriate timeline based on device
    if (isMobile) {
      console.log("Creating mobile timeline...");
      scrollTimeline = createMobileScrollTimeline();
    } else {
      console.log("Creating desktop timeline...");
      scrollTimeline = createDesktopScrollTimeline();
    }

    if (!scrollTimeline) {
      console.warn("Failed to create scroll timeline");
      return;
    }

    // Create ScrollTrigger for the timeline
    ScrollTrigger.create({
      trigger: splitContainer,
      start: "top top", // when the top of the trigger hits the top of the viewport
      end: "+=500", // end after scrolling 500px beyond the start
      pin: true,
      pinSpacing: true,
      scrub: 1,
      animation: scrollTimeline,
      onUpdate: (self) => {
        // Update animation state
        animationState.currentProgress = self.progress;
      },
      onRefresh: () => {
        // Recalculate positions on refresh
        if (isMobile) {
          animationState.scatteredPositions = calculateScatteredPositions(true);
          animationState.singleCardPositions =
            calculateSingleCardPositions(true);
        } else {
          animationState.scatteredPositions =
            calculateScatteredPositions(false);
          animationState.singleCardPositions =
            calculateSingleCardPositions(false);
        }
      },
    });

    // Initial text animation on page load
    gsap.set("#second-title", { opacity: 0, y: 0 });

    gsap.fromTo(
      "#main-title",
      { opacity: 0, y: 50 },
      { opacity: 1, y: 0, duration: 1, ease: "power2.out" }
    );
    gsap.fromTo(
      "#main-description",
      { opacity: 0, y: 30 },
      { opacity: 1, y: 0, duration: 1, delay: 0.3, ease: "power2.out" }
    );
  }

  function initializeGallery() {
    // Clean up existing ScrollTriggers
    ScrollTrigger.getAll().forEach((trigger) => trigger.kill());

    if (animationState.animationFrame) {
      cancelAnimationFrame(animationState.animationFrame);
    }

    // Reset animation state
    animationState.currentProgress = 0;
    animationState.isAnimating = false;
    animationState.scatteredPositions = [];
    animationState.singleCardPositions = [];

    // Setup scroll-controlled animations with ScrollTrigger
    setupScrollAnimation();
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeGallery);
  } else {
    initializeGallery();
  }

  // Re-initialize on navigation (for SPA-like behavior)
  document.addEventListener("astro:page-load", initializeGallery);

  // Re-position on resize with proper layout handling
  window.addEventListener("resize", () => {
    clearTimeout((window as any).resizeTimeout);
    (window as any).resizeTimeout = setTimeout(() => {
      // Refresh ScrollTrigger to recalculate positions and pinning
      ScrollTrigger.refresh();
    }, 250);
  });
</script>
