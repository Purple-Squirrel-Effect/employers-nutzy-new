---
import AboutSection1 from "./AboutSection1.astro";
import BrowserMockup from "./BrowserMockup.astro";
import LogoScrollSection from "./LogoScrollSection.astro";
import NutzyStatsSection from "./NutzyStatsSection.astro";
import ContactSection from "./ContactSection.astro";
import Footer from "./Footer.astro";
import Section from "./Section.astro";

export interface Props {
  cards?: Array<{
    id: string;
    image?: string;
    wireframe?: string;
    alt: string;
    title?: string;
    subtitle?: string;
    websiteType?: string;
    backgroundColor?: string;
  }>;
  className?: string;
}

const {
  cards = [
    {
      id: "card-1",
      wireframe: "/img/wireframes/job-board-wireframe.svg",
      alt: "Job Board Platform",
      title: "JobFind",
      websiteType: "job-board",
      backgroundColor: "bg-primary-500",
    },
    {
      id: "card-2",
      wireframe: "/img/wireframes/linkedin-wireframe.svg",
      alt: "Professional Network",
      title: "CareerNet",
      subtitle: "Professional Platform",
      websiteType: "professional-network",
      backgroundColor: "bg-white",
    },
    {
      id: "card-3",
      wireframe: "/img/wireframes/job-detail-wireframe.svg",
      alt: "Job Detail Page",
      title: "Position View",
      websiteType: "job-detail",
      backgroundColor: "bg-primary-900",
    },
    {
      id: "card-4",
      wireframe: "/img/wireframes/recruitment-dashboard-wireframe.svg",
      alt: "Recruitment Dashboard",
      title: "Talent Hub",
      websiteType: "recruitment-dashboard",
      backgroundColor: "bg-white",
    },
    {
      id: "card-5",
      wireframe: "/img/wireframes/job-board-wireframe.svg",
      alt: "Alternative Job Board",
      title: "TechJobs",
      websiteType: "job-board",
      backgroundColor: "bg-primary-900",
    },
    {
      id: "card-6",
      wireframe: "/img/wireframes/linkedin-wireframe.svg",
      alt: "Professional Platform",
      title: "NetworkPro",
      websiteType: "professional-network",
      backgroundColor: "bg-white",
    },
  ],
  className = "",
} = Astro.props;
---

<!-- ScrollSmoother Wrapper -->
<div id="smooth-wrapper">
  <div id="smooth-content">
    <!-- Main Container with Side-by-Side Layout -->
    <div
      class={`scattered-gallery-container overflow-hidden w-full bg-white relative ${className}`}
      style="min-height: 100vh;"
    >
      <img src="/svg/particle/rocket.svg" alt="Rocket illustration" class="absolute h-screen w-screen top-0 left opacity-40 z-0" loading="lazy" />
      <!-- Background pattern - initially hidden -->
      <div class="absolute inset-0 opacity-0">
        <div class="absolute top-10 left-10 w-4 h-4 bg-white rounded-full">
        </div>
        <div class="absolute top-20 left-32 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute top-32 left-20 w-2 h-2 bg-white rounded-full">
        </div>
        <div class="absolute top-40 left-48 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute top-16 right-20 w-4 h-4 bg-white rounded-full">
        </div>
        <div class="absolute top-36 right-32 w-2 h-2 bg-white rounded-full">
        </div>
        <div class="absolute bottom-20 left-16 w-3 h-3 bg-white rounded-full">
        </div>
        <div class="absolute bottom-32 right-24 w-4 h-4 bg-white rounded-full">
        </div>
      </div>

      <!-- Split Layout Container -->
      <div class="relative w-full h-screen flex" id="split-container">
        <!-- Dynamic Content Container - holds both text and cards -->
        <div class="w-full relative" id="content-container">
          <!-- Text Content - positioned dynamically -->
          <div
            class="absolute inset-0 flex items-center pointer-events-none"
            id="text-container"
          >
            <div
              class="text-content w-full lg:w-1/2 px-8 max-w-lg pointer-events-auto flex items-center justify-center"
              id="text-content"
            >
              <div class="relative">
                <!-- First title - initial state -->
                <h1
                  class="text-4xl md:text-5xl lg:text-8xl font-bold text-black mb-6 drop-shadow-2xl absolute inset-0"
                  id="main-title"
                >
                  Moeite met <br />
                  <span class="text-purple-900">Gen Z</span>
                  bereiken?
                </h1>
                <!-- Second title - target state -->
                <h1
                  class="text-4xl md:text-5xl lg:text-8xl font-bold text-black mb-6 drop-shadow-2xl absolute inset-0 opacity-0"
                  id="second-title"
                >
                  Op <span class="text-purple-900">NUTZY</span>
                  valt je vacature op
                </h1>
                <!-- Invisible spacer to maintain layout height -->
                <h1
                  class="text-4xl md:text-5xl lg:text-8xl font-bold text-black mb-6 opacity-0 pointer-events-none"
                  aria-hidden="true"
                >
                  Moeite met <br />
                  Gen Z bereiken?
                </h1>
              </div>
            </div>
          </div>

          <!-- Cards Container - spans full width for positioning flexibility -->
          <div
            class="absolute top-32 inset-0 pointer-events-none"
            id="cards-container"
          >
            {
              cards.map((card, index) => (
                <div
                  class={`gallery-card absolute rounded-2xl shadow-2xl overflow-hidden transition-all duration-300 hover:scale-105 hover:shadow-3xl hover:z-50 pointer-events-auto`}
                  data-card-id={card.id}
                  data-index={index}
                  data-card
                >
                  <!-- MacBook Mockup Container -->
                  <div class="macbook-mockup relative w-full h-full">
                    <!-- MacBook Device Frame -->
                    <div class="relative z-10 w-full h-full">
                      <img
                        src="/img/macbook-mockup.svg"
                        alt="Browser tab"
                        class="w-full h-full object-contain"
                        loading="lazy"
                      />

                      <!-- Screen Content Overlay -->
                      <div class="absolute inset-0">
                        <!-- Screen area positioned to fill the entire tab -->
                        <div class="screen-content w-full h-full rounded-lg overflow-hidden">
                          {card.wireframe ? (
                            <BrowserMockup
                              wireframeSrc={card.wireframe}
                              websiteTitle={card.title || "Website"}
                              className="w-full h-full"
                            />
                          ) : card.image ? (
                            <img
                              src={card.image}
                              alt={card.alt}
                              class="w-full h-full object-cover"
                              loading="lazy"
                            />
                          ) : (
                            <div class="w-full h-full bg-primary-200 flex items-center justify-center">
                              <span class="text-primary-900 text-sm">No content</span>
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- Card Title Overlay (positioned outside MacBook) -->
                  {(card.title || card.subtitle) && (
                    <div class="absolute -bottom-2 left-1/2 transform -translate-x-1/2 bg-white rounded-lg shadow-lg px-3 py-2 text-center min-w-max">
                      {card.title && (
                        <h3 class="text-sm font-bold text-gray-800 mb-0.5">{card.title}</h3>
                      )}
                      {card.subtitle && (
                        <p class="text-xs text-gray-600">{card.subtitle}</p>
                      )}
                    </div>
                  )}
                </div>
              ))
            }
          </div>

          <!-- iPhone Mockup for target position -->
          <div
            class="absolute inset-0 pointer-events-none"
            id="single-card-container"
          >
            <!-- iPhone positioned on left side for target state - vertically centered like h-screen flex items-center -->
            <div class="w-1/2 h-full flex items-center justify-center">
              <div class="flex items-center justify-center w-full px-8">
                <!-- iPhone Mockup Container - invisible initially, used for positioning -->
                <div
                  class="single-card-placeholder relative"
                  data-single-card-index="0"
                  style="width: min(330px, 70vw); height: min(600px, 85vh); opacity: 0;"
                >
                  <!-- iPhone Device Frame -->
                  <div class="relative z-10 w-full h-full" data-iphone-device>
                    <img
                      src="/img/iphone-mockup.svg"
                      alt="iPhone mockup showing Nutzy product video"
                      class="w-full h-full drop-shadow-2xl"
                      width="300"
                      height="600"
                      loading="lazy"
                    />

                    <!-- Screen Content Overlay with Video -->
                    <div class="absolute inset-0 z-20" data-screen-content>
                      <!-- Video Content Area - Precisely positioned to match iPhone screen -->
                      <div
                        class="absolute overflow-hidden bg-black iphone-screen-container"
                        data-video-container
                        style="
                          top: 13.33%;
                          left: 8.33%;
                          width: 83.33%;
                          height: 73.33%;
                          border-radius: 35px;
                          clip-path: inset(0 round 35px);
                        "
                      >
                        <!-- Video Element with Accessibility Controls -->
                        <video
                          class="w-full h-full object-cover"
                          data-product-video
                          muted
                          loop
                          playsinline
                          preload="metadata"
                          poster="/videos/product.mp4"
                          aria-label="Nutzy platform product demonstration video"
                          style="border-radius: 35px;"
                        >
                          <source
                            src="/videos/product.mp4"
                            type="video/mp4"
                          />
                          <source
                            src="/videos/product.mp4"
                            type="video/webm"
                          />
                          <!-- Fallback content for browsers that don't support video -->
                          <div
                            class="w-full h-full bg-gradient-to-br from-purple-600 to-pink-600 flex items-center justify-center"
                          >
                            <div class="text-center text-white p-6">
                              <div
                                class="w-16 h-16 bg-white bg-opacity-20 rounded-full flex items-center justify-center mx-auto mb-4"
                              >
                                <svg
                                  class="w-8 h-8"
                                  fill="currentColor"
                                  viewBox="0 0 24 24"
                                >
                                  <path d="M8 5v14l11-7z"></path>
                                </svg>
                              </div>
                              <h4 class="text-lg font-semibold mb-2">
                                Product Demo
                              </h4>
                              <p class="text-sm opacity-90">
                                Ontdek Nutzy's platform
                              </p>
                            </div>
                          </div>
                        </video>

                        <!-- Video Controls Overlay (for accessibility) -->
                        <div
                          class="absolute inset-0 bg-black bg-opacity-0 hover:bg-opacity-20 transition-all duration-300 cursor-pointer flex items-center justify-center opacity-0 hover:opacity-100"
                          data-video-overlay
                          role="button"
                          tabindex="0"
                          aria-label="Play/pause product video"
                        >
                          <div
                            class="w-12 h-12 bg-white bg-opacity-80 rounded-full flex items-center justify-center"
                          >
                            <svg
                              class="w-6 h-6 text-gray-800"
                              fill="currentColor"
                              viewBox="0 0 24 24"
                              data-play-icon
                            >
                              <path d="M8 5v14l11-7z"></path>
                            </svg>
                            <svg
                              class="w-6 h-6 text-gray-800 hidden"
                              fill="currentColor"
                              viewBox="0 0 24 24"
                              data-pause-icon
                            >
                              <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"></path>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- End Split Layout Container -->
    </div>
    
    <!-- End Main Container -->
    <AboutSection1 />
    <Section
      sectionClassName="bg-secondary-900 relative z-10 shadow-2xl"

      className="z-10  relative flex py-16 gap-16 justify-center items-center "
    >

  
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 relative w-full ">
       
        <div class="w-full order-2">
          <video class="h-full w-full rounded-lg" loop  autoplay muted src="/videos/Screen Recording 2025-07-16 104626.mp4" class="bg-cover h-full w-full" src="/img/fanpage.png" alt="Fanpage" />
        </div>
         <div class="relative order-1 w-full" >  
            <img
              class="absolute opacity-10 z-10 "
              src="svg/Web-devices-cuate.svg"
              alt="Life-amico"
            />
            <h2 class="text-6xl font-bold text-white mb-6 text-shadow shadow-black">
              Fanpage
            </h2>
            <p class="text-white">
              Vacatureteksten, visueel. We brengen vacatureteksten visueel tot
              leven, zodat Gen Z in één oogopslag ziet hoe hun toekomstige job
              eruitziet. Wij richten ons op stages, traineeships en junior (2 jaar
              werkervaring) vacatureprofielen.
            </p>
        </div>
      </div>
    </Section>
    <LogoScrollSection />
    <NutzyStatsSection />
    <ContactSection />
    <Footer />
  </div>
</div>

<style>
  .scattered-gallery-container {
    position: relative;
    min-height: 100vh;
    transition: background-color 0.3s ease-out;
    will-change: background-color;
  }

  /* Split container for pinning */
  #split-container {
    position: relative;
    width: 100%;
    height: 100vh;
  }

  /* Content container for flexible positioning */
  #content-container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  /* Text content positioning */
  .text-content {
    position: relative;
    transition: transform 0.1s ease-out;
    will-change: transform;
  }

  /* Text elements with smooth color transitions */
  .text-content h1,
  .text-content p {
    transition: color 0.3s ease-out;
    will-change: color;
  }

  /* Gallery cards */
  .gallery-card {
    cursor: pointer;
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform, left, top, width, height, box-shadow, filter;
    transition:
      box-shadow 0.3s ease-out,
      filter 0.3s ease-out;
    /* Default sizes that will be overridden by JS */
    width: 280px;
    height: 200px;
  }

  /* Single card container positioning */
  #single-card-container {
    pointer-events: none;
  }

  /* Mobile responsive adjustments for vertical layout */
  @media (max-width: 768px) {
    .gallery-card {
      width: 180px;
      height: 135px;
    }

    .text-content {
      padding: 1rem;
      /* Allow for mobile positioning via GSAP */
      position: absolute !important;
      width: 100% !important;
      max-width: none !important;
      /* Remove any default positioning that might interfere */
      left: auto !important;
      right: auto !important;
      transform: none !important;
      text-align: center !important;
    }

    /* Mobile-specific text positioning */
    #text-container {
      position: absolute !important;
      width: 100% !important;
      height: 100% !important;
      /* Override desktop flex positioning */
      display: block !important;
      align-items: unset !important;
      /* Remove any default positioning */
      top: 0 !important;
      left: 0 !important;
    }

    /* Mobile iPhone mockup positioning - centered at top */
    .single-card-placeholder {
      max-width: 280px !important;
      max-height: 500px !important;
      margin: 0 auto !important;
    }

    /* Override desktop side-by-side layout for mobile */
    #single-card-container {
      width: 100% !important;
      display: flex !important;
      justify-content: center !important;
      align-items: flex-start !important;
      padding-top: 10vh !important;
    }

    #single-card-container .w-1\/2 {
      width: 100% !important;
    }

    /* Override desktop flex layout for mobile */
    #split-container {
      display: block !important;
      height: 100vh !important;
    }

    #content-container {
      position: relative !important;
      height: 100vh !important;
    }

    /* Mobile text sizing adjustments */
    .text-content h1 {
      font-size: 2.5rem !important;
      line-height: 1.1 !important;
      margin-bottom: 1rem !important;
      text-align: center !important;
    }

    /* Cards container for mobile - allow full height for scattered positioning */
    #cards-container {
      top: 0 !important;
      height: 100vh !important;
    }

    /* Ensure proper stacking for mobile */
    #single-card-container {
      z-index: 20 !important;
    }

    #text-container {
      z-index: 30 !important;
    }

    #cards-container {
      z-index: 10 !important;
    }
  }

  /* Small mobile adjustments */
  @media (max-width: 480px) {
    .gallery-card {
      width: 160px;
      height: 120px;
    }

    .scattered-gallery-container {
      padding: 1rem;
    }

    .text-content h1 {
      font-size: 2rem !important;
    }

    .text-content p {
      font-size: 1rem !important;
    }
  }

  /* Accessibility: Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .gallery-card {
      transition: none !important;
      transform: none !important;
    }

    .gallery-card:hover {
      transform: none !important;
    }

    .text-content {
      transition: none !important;
    }

    /* Disable all GSAP animations for reduced motion */
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* Enhanced shadow for hover state */
  .gallery-card:hover {
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
  }

  /* Focus styles for accessibility */
  .gallery-card:focus {
    outline: 2px solid rgba(255, 255, 255, 0.8);
    outline-offset: 4px;
  }

  /* Smooth performance optimizations */
  .gallery-card,
  .text-content {
    transform: translateZ(0); /* Force hardware acceleration */
  }

  /* Logo container styles */
  .logo-container {
    position: absolute;
    top: 1.5rem;
    left: 1.5rem;
    z-index: 50;
    transition: all 0.3s ease-out;
    will-change: color, transform;
  }

  /* Logo responsive adjustments */
  @media (max-width: 640px) {
    .logo-container {
      top: 1rem;
      left: 1rem;
    }

    .logo-container .text-xl {
      font-size: 1.125rem;
    }
  }

  /* Logo color transitions for scroll animations */
  .logo-container a span {
    transition: color 0.3s ease-out;
    will-change: color;
  }

  /* Ensure logo stays above all other elements */
  .logo-container {
    pointer-events: auto;
  }

  /* Logo accessibility improvements */
  .logo-container a:focus {
    outline: 2px solid rgba(255, 255, 255, 0.8);
    outline-offset: 4px;
    border-radius: 0.75rem;
  }

  /* Logo hover effects */
  .logo-container a:hover .text-primary-900 {
    color: #a855f7;
  }

  /* iPhone Screen Container - Precise video containment */
  .iphone-screen-container {
    /* Ensure video is perfectly contained within iPhone screen boundaries */
    position: absolute;
    overflow: hidden;
    /* Use CSS mask for perfect screen shape matching */
    -webkit-mask: radial-gradient(
      ellipse at center,
      black 99%,
      transparent 100%
    );
    mask: radial-gradient(ellipse at center, black 99%, transparent 100%);
    /* Additional containment for video overflow */
    contain: layout style paint;
  }

  .iphone-screen-container video {
    /* Ensure video respects container boundaries */
    max-width: 100%;
    max-height: 100%;
    object-fit: cover;
    object-position: center;
    /* Prevent any potential overflow */
    transform: scale(0.999); /* Slight scale down to ensure no edge overflow */
  }

  /* Ensure proper stacking and containment */
  [data-screen-content] {
    /* Create a new stacking context */
    isolation: isolate;
    /* Ensure content doesn't overflow iPhone frame */
    overflow: hidden;
  }
</style>

<script>
  import { gsap } from "gsap";
import { Flip } from "gsap/Flip";
import { ScrollSmoother } from "gsap/ScrollSmoother";
import { ScrollTrigger } from "gsap/ScrollTrigger";

  // Register GSAP plugins
  gsap.registerPlugin(Flip, ScrollTrigger, ScrollSmoother);

  interface CardPosition {
    x: number;
    y: number;
    rotation: number;
    width: number;
    height: number;
    zIndex: number;
  }

  interface AnimationState {
    scatteredPositions: CardPosition[];
    singleCardPositions: CardPosition[];
    currentProgress: number;
    isAnimating: boolean;
    animationFrame: number | null;
    scrollStart: number;
    scrollEnd: number;
  }

  // Seeded random number generator for consistent but random-looking layout
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  function generateCardPositions(
    cardCount: number,
    containerWidth: number,
    containerHeight: number,
    isMobile: boolean = false
  ): CardPosition[] {
    const positions: CardPosition[] = [];
    const padding = 50; // Minimum distance from edges
    const minDistance = 100; // Minimum distance between card centers

    for (let i = 0; i < cardCount; i++) {
      let attempts = 0;
      let position: CardPosition;

      do {
        // Use index as seed for consistent positioning across reloads
        const seedX = i * 123 + attempts * 7;
        const seedY = i * 456 + attempts * 13;
        const seedRot = i * 789 + attempts * 19;
        const seedSize = i * 321 + attempts * 11;

        let x: number, y: number;

        if (isMobile) {
          // Mobile: scatter cards across full width, in middle section (avoiding text areas)
          const mobileTopOffset = containerHeight * 0.3; // Start cards below initial text area
          const mobileBottomOffset = containerHeight * 0.2; // Leave space for final text area
          const availableHeight = containerHeight - mobileTopOffset - mobileBottomOffset;
          x = padding + seededRandom(seedX) * (containerWidth - padding * 2 - 180);
          y = mobileTopOffset + seededRandom(seedY) * availableHeight;
        } else {
          // Desktop: constrain to right half of container (initial state)
          const rightHalfStart = containerWidth / 2;
          const rightHalfWidth = containerWidth / 2;
          x = rightHalfStart + padding + seededRandom(seedX) * (rightHalfWidth - padding * 2 - 300);
          y = padding + seededRandom(seedY) * (containerHeight - padding * 2 - 250);
        }

        // Random rotation between -20 and 20 degrees
        const rotation = (seededRandom(seedRot) - 0.5) * 40;

        // Slight size variation
        const sizeVariation = seededRandom(seedSize) * 40 - 20;
        const width = Math.max(200, 280 + sizeVariation);
        const height = Math.max(150, 200 + sizeVariation * 0.7);

        position = {
          x,
          y,
          rotation,
          width,
          height,
          zIndex: 10 + i,
        };

        // Check if position overlaps with existing cards
        const overlaps = positions.some((existingPos) => {
          const dx = position.x - existingPos.x;
          const dy = position.y - existingPos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });

        if (!overlaps || attempts > 50) {
          break;
        }

        attempts++;
      } while (attempts < 100);

      positions.push(position);
    }

    return positions;
  }

  // Global animation state
  let animationState: AnimationState = {
    scatteredPositions: [],
    singleCardPositions: [],
    currentProgress: 0,
    isAnimating: false,
    animationFrame: null,
    scrollStart: 0,
    scrollEnd: 0,
  };

  function calculateScatteredPositions(isMobile: boolean = false): CardPosition[] {
    const container = document.getElementById("cards-container");
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;

    if (!container || cards.length === 0) return [];

    const containerRect = container.getBoundingClientRect();
    const containerWidth = containerRect.width;
    const containerHeight = Math.max(containerRect.height, window.innerHeight);

    // Generate positions with mobile flag
    return generateCardPositions(cards.length, containerWidth, containerHeight, isMobile);
  }

  function calculateSingleCardPositions(isMobile: boolean = false): CardPosition[] {
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const singleCardPlaceholder = document.querySelector(
      ".single-card-placeholder"
    ) as HTMLElement;

    if (cards.length === 0 || !singleCardPlaceholder) return [];

    const positions: CardPosition[] = [];
    const containerRect = document
      .getElementById("cards-container")!
      .getBoundingClientRect();

    let left: number, top: number, width: number, height: number;

    if (isMobile) {
      // Mobile: Professional sizing - iPhone positioned at top center
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const mobileWidth = Math.min(viewportWidth * 0.7, 300); // 70% of viewport width, max 300px
      const mobileHeight = Math.min(mobileWidth * 1.8, viewportHeight * 0.45); // Maintain iPhone aspect ratio, max 45% viewport height
      left = (viewportWidth - mobileWidth) / 2;
      top = viewportHeight * 0.1; // 10% from top for compact positioning
      width = mobileWidth;
      height = mobileHeight;
    } else {
      // Desktop: Use existing placeholder positioning but make it smaller
      const placeholderRect = singleCardPlaceholder.getBoundingClientRect();
      left = placeholderRect.left - containerRect.left;
      top = placeholderRect.top - containerRect.top;
      // Make desktop mockup smaller - 80% of original size
      width = placeholderRect.width * 0.8;
      height = placeholderRect.height * 0.8;
      // Adjust position to keep it centered after size reduction
      left += (placeholderRect.width - width) / 2;
      top += (placeholderRect.height - height) / 2;
    }

    // Create position for the first card (which will be the prominent one)
    const prominentCardPosition: CardPosition = {
      x: left,
      y: top,
      width: width,
      height: height,
      rotation: 0,
      zIndex: 20, // Higher z-index for prominence
    };

    // For the first card, use the prominent position
    positions.push(prominentCardPosition);

    // For all other cards, position them off-screen or make them invisible
    // by positioning them at the same location but with opacity 0
    cards.forEach((_, index) => {
      if (index > 0) {
        positions.push({
          x: left,
          y: top,
          width: width,
          height: height,
          rotation: 0,
          zIndex: 1, // Lower z-index, will be hidden
        });
      }
    });

    return positions;
  }

  // Create mobile GSAP timeline for vertical scroll-controlled animation
  function createMobileScrollTimeline(): gsap.core.Timeline {
    const timeline = gsap.timeline({ paused: true });
    const cards = document.querySelectorAll("[data-card]") as NodeListOf<HTMLElement>;
    const textContent = document.getElementById("text-content");
    const mainTitle = document.getElementById("main-title");
    const secondTitle = document.getElementById("second-title");
    const container = document.querySelector(".scattered-gallery-container") as HTMLElement;

    console.log("Creating mobile vertical timeline");
    console.log(`Found ${cards.length} cards`);

    if (cards.length === 0 || !textContent || !mainTitle || !secondTitle || !container) {
      console.warn("Missing required elements for mobile timeline");
      return timeline;
    }

    // Calculate mobile positions
    const scatteredPositions = calculateScatteredPositions(true);
    const singleCardPositions = calculateSingleCardPositions(true);

    // Store positions in animation state
    animationState.scatteredPositions = scatteredPositions;
    animationState.singleCardPositions = singleCardPositions;

    // Set initial scattered positions for mobile (cards in middle area)
    cards.forEach((card, index) => {
      const pos = scatteredPositions[index];
      if (!pos) return;

      gsap.set(card, {
        left: pos.x,
        top: pos.y,
        width: pos.width,
        height: pos.height,
        rotation: pos.rotation,
        zIndex: pos.zIndex,
        opacity: 1,
      });
    });

    // Set initial state for iPhone mockup (hidden)
    const mockupContainer = document.querySelector(".single-card-placeholder") as HTMLElement;
    if (mockupContainer) {
      gsap.set(mockupContainer, {
        opacity: 0,
        scale: 0.8,
      });
    }

    // Set initial text position for mobile - start at top center
    gsap.set(textContent, {
      x: "50%",
      y: 0,
      xPercent: -50, // This centers the element horizontally
      top: "20%", // Start at top 20% of screen
      position: "absolute",
      width: "100%",
      textAlign: "center"
    });
    gsap.set(mainTitle, { opacity: 1 });
    gsap.set(secondTitle, { opacity: 0 });

    // Set initial background state
    gsap.set(container, { backgroundColor: "#bd7ef2" });

    // Mobile timeline animations - vertical layout
    console.log("Setting up mobile timeline phases...");

    // Phase 1: Fade out scattered cards (0-0.6s)
    cards.forEach((card, index) => {
      timeline.to(card, {
        opacity: 0,
        scale: 0.8,
        duration: 0.6,
        ease: "power2.inOut",
      }, 0);
    });

    // Phase 2: Move text from top to bottom (0.2-1.0s)
    timeline.to(textContent, {
      top: "85%", // Move to 85% of screen (5% less than 90%)
      duration: 0.8,
      ease: "power2.inOut",
    }, 0.2);

    // Phase 3: Show iPhone mockup at top (0.4-1.2s)
    if (mockupContainer) {
      timeline.to(mockupContainer, {
        opacity: 1,
        scale: 1,
        duration: 0.8,
        ease: "power2.out",
      }, 0.4);
    }

    // Phase 4: Background transition (0-1.0s)
    timeline.to(container, {
      backgroundColor: "#25B4B3",
      duration: 1,
      ease: "power2.inOut",
    }, 0);

    // Phase 5: Text transition (0.3-0.9s) - using fromTo for better reversibility
    timeline.fromTo(mainTitle,
      { opacity: 1 },
      {
        opacity: 0,
        duration: 0.4,
        ease: "power2.inOut",
      }, 0.3);

    timeline.fromTo(secondTitle,
      { opacity: 0 },
      {
        opacity: 1,
        duration: 0.4,
        ease: "power2.inOut",
      }, 0.5);

    console.log("Mobile timeline created successfully");
    return timeline;
  }

  // Create desktop GSAP timeline for scroll-controlled animation
  function createDesktopScrollTimeline(): gsap.core.Timeline {
    const timeline = gsap.timeline({ paused: true });
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;
    const textContent = document.getElementById("text-content");
    const mainTitle = document.getElementById("main-title");
    const secondTitle = document.getElementById("second-title");
    const mainDescription = document.getElementById("main-description");
    const container = document.querySelector(
      ".scattered-gallery-container"
    ) as HTMLElement;
    const backgroundPattern = container?.querySelector(
      ".absolute.inset-0.opacity-10"
    ) as HTMLElement;

    if (
      cards.length === 0 ||
      !textContent ||
      !mainTitle ||
      !secondTitle ||
      !container
    )
      return timeline;

    // Calculate desktop positions
    const scatteredPositions = calculateScatteredPositions(false);
    const singleCardPositions = calculateSingleCardPositions(false);

    // Store positions in animation state
    animationState.scatteredPositions = scatteredPositions;
    animationState.singleCardPositions = singleCardPositions;

    // Set initial scattered positions for desktop
    cards.forEach((card, index) => {
      const pos = scatteredPositions[index];
      if (!pos) return;

      gsap.set(card, {
        left: pos.x,
        top: pos.y,
        width: pos.width,
        height: pos.height,
        rotation: pos.rotation,
        zIndex: pos.zIndex,
        opacity: 1,
      });
    });

    // Set initial state for iPhone mockup (hidden and scaled down)
    const mockupContainer = document.querySelector(
      ".single-card-placeholder"
    ) as HTMLElement;
    if (mockupContainer) {
      gsap.set(mockupContainer, {
        opacity: 0,
        scale: 0.8,
      });
    }

    // Set initial text position (left side) and title states
    gsap.set(textContent, { x: 0 });
    gsap.set(mainTitle, { opacity: 1 });
    gsap.set(secondTitle, { opacity: 0 });

    // Set initial background state
    gsap.set(container, { backgroundColor: "#bd7ef2" });
    if (backgroundPattern) {
      gsap.set(backgroundPattern, { opacity: 0 });
    }

    // Set initial logo state (purple color for white background)
    const initialLogoText = document.querySelector(".logo-container span");
    if (initialLogoText) {
      gsap.set(initialLogoText, { color: "#581c87" }); // Initial purple color
    }

    // Desktop timeline animations - fade out all cards and show iPhone mockup
    cards.forEach((card, index) => {
      timeline.to(
        card,
        {
          opacity: 0,
          scale: 0.8,
          duration: 0.8,
          ease: "power2.inOut",
        },
        0
      );
    });

    // Show iPhone mockup after cards fade out
    if (mockupContainer) {
      timeline.to(
        mockupContainer,
        {
          opacity: 1,
          scale: 1,
          duration: 0.8,
          ease: "power2.out",
        },
        0.4
      );
    }

    // Animate text from left to right
    const containerRect = document
      .getElementById("content-container")!
      .getBoundingClientRect();
    const rightSideStart = containerRect.width / 2;

    timeline.to(
      textContent,
      {
        x: rightSideStart,
        duration: 1,
        ease: "power2.inOut",
      },
      0
    );

    // Background transition
    timeline.to(
      container,
      {
        backgroundColor: "#25B4B3",
        duration: 1,
        ease: "power2.inOut",
      },
      0
    );

    // Fade out background pattern during transition
    if (backgroundPattern) {
      timeline.to(
        backgroundPattern,
        {
          opacity: 0,
          duration: 0.8,
          ease: "power2.inOut",
        },
        0.1
      );
    }

    // Change text colors to white for better contrast
    const textElements = [mainTitle, secondTitle];
    if (mainDescription) {
      textElements.push(mainDescription);
    }

    timeline.to(
      textElements,
      {
        color: "#ffffff",
        duration: 0.8,
        ease: "power2.inOut",
      },
      0.2
    );

    // Change logo text color to white for better contrast
    const animationLogoText = document.querySelector(".logo-container span");
    if (animationLogoText) {
      timeline.to(
        animationLogoText,
        {
          color: "#ffffff",
          duration: 0.8,
          ease: "power2.inOut",
        },
        0.2
      );
    }

    // Text transition animation - fade out first title and fade in second title
    timeline.to(
      mainTitle,
      {
        opacity: 0,
        duration: 0.4,
        ease: "power2.inOut",
      },
      0.3
    );

    timeline.to(
      secondTitle,
      {
        opacity: 1,
        duration: 0.4,
        ease: "power2.inOut",
      },
      0.5
    );

    return timeline;
  }



  // Global timeline variable
  let scrollTimeline: gsap.core.Timeline | null = null;

  function setupScrollAnimation() {
    const container = document.querySelector(".scattered-gallery-container");
    const splitContainer = document.querySelector("#split-container");
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;

    if (!container || !splitContainer || prefersReducedMotion) {
      // Set initial state for reduced motion - show first title only
      gsap.set("#main-title", { opacity: 1, y: 0, color: "#000000" });
      gsap.set("#second-title", { opacity: 0, y: 0, color: "#000000" });
      gsap.set("#main-description", { opacity: 1, y: 0, color: "#000000" });

      // Set initial logo state for reduced motion
      const reducedMotionLogoText = document.querySelector(
        ".logo-container span"
      );
      if (reducedMotionLogoText) {
        gsap.set(reducedMotionLogoText, { color: "#581c87" }); // Keep original purple color
      }
      return;
    }

    // Detect mobile vs desktop
    const isMobile = window.innerWidth <= 768;
    console.log(`Setting up ${isMobile ? 'mobile' : 'desktop'} scroll animation`);
    console.log(`Window dimensions: ${window.innerWidth}x${window.innerHeight}`);

    // Create appropriate timeline based on device
    if (isMobile) {
      console.log("Creating mobile timeline...");
      scrollTimeline = createMobileScrollTimeline();
    } else {
      console.log("Creating desktop timeline...");
      scrollTimeline = createDesktopScrollTimeline();
    }

    if (!scrollTimeline) {
      console.warn("Failed to create scroll timeline");
      return;
    }

    // Create ScrollTrigger for the timeline
    ScrollTrigger.create({
      trigger: splitContainer,
      start: "top top",
      end: "bottom top",
      pin: true,
      pinSpacing: true,
      scrub: 1,
      animation: scrollTimeline,
      onUpdate: (self) => {
        // Update animation state
        animationState.currentProgress = self.progress;
      },
      onRefresh: () => {
        // Recalculate positions on refresh
        if (isMobile) {
          animationState.scatteredPositions = calculateScatteredPositions(true);
          animationState.singleCardPositions = calculateSingleCardPositions(true);
        } else {
          animationState.scatteredPositions = calculateScatteredPositions(false);
          animationState.singleCardPositions = calculateSingleCardPositions(false);
        }
      }
    });

    // Initial text animation on page load
    gsap.set("#second-title", { opacity: 0, y: 0 });

    gsap.fromTo(
      "#main-title",
      { opacity: 0, y: 50 },
      { opacity: 1, y: 0, duration: 1, ease: "power2.out" }
    );
    gsap.fromTo(
      "#main-description",
      { opacity: 0, y: 30 },
      { opacity: 1, y: 0, duration: 1, delay: 0.3, ease: "power2.out" }
    );
  }

  function setupVideoControls() {
    const video = document.querySelector(
      "[data-product-video]"
    ) as HTMLVideoElement;
    const videoOverlay = document.querySelector(
      "[data-video-overlay]"
    ) as HTMLElement;
    const playIcon = document.querySelector("[data-play-icon]") as HTMLElement;
    const pauseIcon = document.querySelector(
      "[data-pause-icon]"
    ) as HTMLElement;

    if (!video || !videoOverlay || !playIcon || !pauseIcon) return;

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;

    // If user prefers reduced motion, pause the video and show controls
    if (prefersReducedMotion) {
      video.pause();
      video.removeAttribute("autoplay");
    } else {
      // Auto-play video when it becomes visible (respecting user preferences)
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
              video.play().catch(() => {
                // Auto-play failed, show controls
                videoOverlay.style.opacity = "1";
              });
            } else {
              video.pause();
            }
          });
        },
        { threshold: 0.5 }
      );

      observer.observe(video);
    }

    // Video control functionality
    function toggleVideo() {
      if (video.paused) {
        video.play();
        playIcon.classList.add("hidden");
        pauseIcon.classList.remove("hidden");
      } else {
        video.pause();
        playIcon.classList.remove("hidden");
        pauseIcon.classList.add("hidden");
      }
    }

    // Add click handler for video overlay
    videoOverlay.addEventListener("click", toggleVideo);

    // Add keyboard support for video overlay
    videoOverlay.addEventListener("keydown", (e: KeyboardEvent) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        toggleVideo();
      }
    });

    // Update icon state when video state changes
    video.addEventListener("play", () => {
      playIcon.classList.add("hidden");
      pauseIcon.classList.remove("hidden");
    });

    video.addEventListener("pause", () => {
      playIcon.classList.remove("hidden");
      pauseIcon.classList.add("hidden");
    });

    // Handle video loading errors gracefully
    video.addEventListener("error", () => {
      console.warn("Video failed to load, showing fallback content");
      const fallbackContent = video.nextElementSibling as HTMLElement;
      if (fallbackContent) {
        video.style.display = "none";
        fallbackContent.style.display = "flex";
      }
    });
  }

  function initializeGallery() {
    // Clean up existing ScrollTriggers
    ScrollTrigger.getAll().forEach((trigger) => trigger.kill());

    if (animationState.animationFrame) {
      cancelAnimationFrame(animationState.animationFrame);
    }

    // Reset animation state
    animationState.currentProgress = 0;
    animationState.isAnimating = false;
    animationState.scatteredPositions = [];
    animationState.singleCardPositions = [];

    // Setup scroll-controlled animations with ScrollTrigger
    setupScrollAnimation();

    // Setup video functionality
    setupVideoControls();

    // Setup card interactions
    const cards = document.querySelectorAll(
      "[data-card]"
    ) as NodeListOf<HTMLElement>;

    cards.forEach((card, index) => {
      // Add keyboard navigation
      card.setAttribute("tabindex", "0");
      card.setAttribute("role", "button");
      card.setAttribute("aria-label", `Brand card ${index + 1}`);

      // Add click handler for potential interactions
      card.addEventListener("click", () => {
        console.log(`Card ${index + 1} clicked`);
        // Add your click logic here
      });

      // Add keyboard support
      card.addEventListener("keydown", (e: KeyboardEvent) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          (card as HTMLElement).click();
        }
      });

      // Enhanced hover effects (respecting reduced motion)
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;

      if (!prefersReducedMotion) {
        let originalTransform = "";

        card.addEventListener("mouseenter", () => {
          originalTransform = card.style.transform;
          card.style.transform =
            originalTransform + " translateY(-10px) scale(1.05)";
        });

        card.addEventListener("mouseleave", () => {
          card.style.transform = originalTransform;
        });
      }
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeGallery);
  } else {
    initializeGallery();
  }

  // Re-initialize on navigation (for SPA-like behavior)
  document.addEventListener("astro:page-load", initializeGallery);

  // Re-position on resize with proper layout handling
  window.addEventListener("resize", () => {
    clearTimeout((window as any).resizeTimeout);
    (window as any).resizeTimeout = setTimeout(() => {
      // Refresh ScrollTrigger to recalculate positions and pinning
      ScrollTrigger.refresh();
    }, 250);
  });
</script>
