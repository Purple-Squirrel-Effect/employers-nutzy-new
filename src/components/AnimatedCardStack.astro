---
export interface Props {
  cards?: Array<{
    id: string;
    title: string;
    content?: string;
    image?: string;
  }>;
  className?: string;
}

const {
  cards = [
    {
      id: "card-1",
      title: "Professional Design",
      content: "Modern and clean interface",
    },
    {
      id: "card-2",
      title: "Smooth Animations",
      content: "Powered by GSAP technology",
    },
    {
      id: "card-3",
      title: "Responsive Layout",
      content: "Works on all screen sizes",
    },
    { id: "card-4", title: "Accessible", content: "Respects user preferences" },
  ],
  className = "",
} = Astro.props;
---

<!-- Card deck section with individual sticky cards -->
<div class={`card-deck-container ${className}`} data-cards-container>
  {
    cards.map((card, index) => (
      <div class="sticky-card-wrapper" data-card-wrapper={index}>
        <div
          class="card-item bg-white w-80 h-96 rounded-xl shadow-2xl overflow-hidden"
          data-card={card.id}
          data-index={index}
        >
          <div class="card-content p-8 h-full flex flex-col justify-center items-center text-center">
            {card.image ? (
              <img
                src={card.image}
                alt={card.title}
                class="w-full h-32 object-cover rounded-lg mb-4"
              />
            ) : (
              <div class="w-full h-32 bg-gradient-to-br from-purple-100 to-pink-100 rounded-lg mb-4 flex items-center justify-center">
                <div class="w-16 h-16 bg-gradient-to-br from-purple-500 to-pink-500 rounded-full opacity-20" />
              </div>
            )}
            <h3 class="text-2xl font-semibold text-gray-800 mb-2">
              {card.title}
            </h3>
            {card.content && (
              <p class="text-gray-600 text-lg leading-relaxed">
                {card.content}
              </p>
            )}
          </div>
        </div>
      </div>
    ))
  }
</div>

<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  // Register ScrollTrigger plugin
  gsap.registerPlugin(ScrollTrigger);

  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia(
    "(prefers-reduced-motion: reduce)"
  ).matches;

  interface CardSwipeAnimation {
    container: HTMLElement;
    cards: NodeListOf<HTMLElement>;
    currentCardIndex: number;
    scrollTriggers: ScrollTrigger[];
  }

  function initializeDeckSwipeAnimation(): CardSwipeAnimation | null {
    const container = document.querySelector(
      "[data-cards-container]"
    ) as HTMLElement;
    if (!container) return null;

    const cards = container.querySelectorAll(
      ".card-item"
    ) as NodeListOf<HTMLElement>;
    if (cards.length === 0) return null;

    // Don't override the CSS-defined height, just use it for calculations
    // The height is already set via inline style in the HTML template
    const containerHeight = container.offsetHeight;
    const scrollDistancePerCard = (containerHeight / cards.length) * 0.8;

    // Initialize card positions - all cards start stacked
    gsap.set(cards, {
      x: 0,
      y: 0,
      rotation: 0,
      scale: 1,
      opacity: 1,
      zIndex: (index: number) => cards.length - index,
    });

    // Add subtle stacking effect for depth
    if (!prefersReducedMotion) {
      cards.forEach((card, index) => {
        gsap.set(card, {
          y: index * -2,
          x: index * 1,
          rotation: (index - cards.length / 2) * 0.5,
        });
      });
    }

    const animation: CardSwipeAnimation = {
      container,
      cards,
      currentCardIndex: 0,
      scrollTriggers: [],
    };

    return animation;
  }

  function createCardSwipeScrollTriggers(animation: CardSwipeAnimation) {
    const { container, cards } = animation;

    // Calculate scroll distance based on container height and number of cards
    const containerHeight = container.offsetHeight;
    const scrollDistancePerCard = containerHeight / cards.length;

    cards.forEach((card, index) => {
      // Calculate scroll positions for this card based on container height
      const startProgress = index * scrollDistancePerCard;
      const endProgress = (index + 1) * scrollDistancePerCard;

      // Create scroll trigger for each card swipe
      const scrollTrigger = ScrollTrigger.create({
        trigger: container,
        start: `top+=${startProgress} bottom`,
        end: `top+=${endProgress} bottom`,
        scrub: 1.2, // Smooth scrubbing
        onUpdate: (self) => {
          const progress = self.progress;

          if (prefersReducedMotion) {
            // Simple fade out for reduced motion
            gsap.set(card, {
              opacity: 1 - progress,
              display: progress >= 1 ? "none" : "block",
            });
          } else {
            // Full swipe animation
            const swipeDirection = index % 2 === 0 ? 1 : -1; // Alternate swipe directions
            const xOffset = progress * 400 * swipeDirection;
            const rotation = progress * 15 * swipeDirection;
            const scale = 1 - progress * 0.1;
            const opacity = 1 - progress * 0.8;

            gsap.set(card, {
              x: xOffset,
              rotation: rotation,
              scale: Math.max(scale, 0.8),
              opacity: Math.max(opacity, 0),
              display: progress >= 1 ? "none" : "block",
            });
          }
        },
        onToggle: (self) => {
          // Update current card index for accessibility
          if (self.isActive) {
            animation.currentCardIndex = index;
          }
        },
      });

      animation.scrollTriggers.push(scrollTrigger);
    });
  }

  function addCardHoverEffects(animation: CardSwipeAnimation) {
    if (prefersReducedMotion) return;

    const { cards } = animation;

    cards.forEach((card, index) => {
      card.addEventListener("mouseenter", () => {
        // Only animate if card is currently visible
        const isVisible = (gsap.getProperty(card, "opacity") as number) > 0.5;
        if (!isVisible) return;

        gsap.to(card, {
          scale: 1.05,
          y: -10,
          duration: 0.3,
          ease: "power2.out",
        });
      });

      card.addEventListener("mouseleave", () => {
        const isVisible = (gsap.getProperty(card, "opacity") as number) > 0.5;
        if (!isVisible) return;

        gsap.to(card, {
          scale: 1,
          y: index * -2, // Return to original stacked position
          duration: 0.3,
          ease: "power2.out",
        });
      });
    });
  }

  function initializeAnimations() {
    // Clean up existing scroll triggers
    ScrollTrigger.getAll().forEach((trigger) => trigger.kill());

    const animation = initializeDeckSwipeAnimation();
    if (!animation) return;

    createCardSwipeScrollTriggers(animation);
    addCardHoverEffects(animation);

    // Add keyboard navigation for accessibility
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowDown" || e.key === "ArrowUp") {
        e.preventDefault();
        const direction = e.key === "ArrowDown" ? 1 : -1;
        const container = document.querySelector(
          "[data-cards-container]"
        ) as HTMLElement;
        if (container) {
          const containerHeight = container.offsetHeight;
          const cards = container.querySelectorAll(".card-item");
          const scrollAmount = (containerHeight / cards.length) * direction;
          window.scrollBy({ top: scrollAmount, behavior: "smooth" });
        }
      }
    });
  }

  // Initialize animations when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeAnimations);
  } else {
    initializeAnimations();
  }

  // Re-initialize on navigation (for SPA-like behavior)
  document.addEventListener("astro:page-load", initializeAnimations);

  // Handle resize events
  window.addEventListener("resize", () => {
    // Debounce resize events
    clearTimeout((window as any).resizeTimeout);
    (window as any).resizeTimeout = setTimeout(initializeAnimations, 250);
  });
</script>

<style>
  .card-deck-container {
    position: relative;
  }

  .sticky-card-wrapper {
    min-height: 100vh;
  }

  .card-item {
    position: sticky;
    top: 47.5vh;
    margin-left: auto;
    margin-right: auto;
    transform-style: preserve-3d;
    backface-visibility: hidden;
    transition: box-shadow 0.3s ease;
  }

  .card-item:hover {
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  }

  .card-content {
    will-change: transform;
  }

  /* Ensure smooth transitions and performance */
  .card-item * {
    will-change: auto;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .card-item {
      width: 300px;
      height: 360px;
    }

    .card-content {
      padding: 1.5rem;
    }

    .card-content h3 {
      font-size: 1.25rem;
    }

    .card-content p {
      font-size: 0.875rem;
    }
  }

  @media (max-width: 480px) {
    .card-item {
      width: 260px;
      height: 320px;
    }

    .card-content {
      padding: 1rem;
    }

    .card-content h3 {
      font-size: 1.125rem;
    }

    .card-content p {
      font-size: 0.8rem;
    }
  }

  /* Accessibility: Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .card-item {
      transition: none;
    }
  }

  /* Ensure clean section boundaries */
  .card-deck-container::before,
  .card-deck-container::after {
    content: "";
    display: block;
    height: 1px;
    width: 100%;
    clear: both;
  }

  /* Smooth scrolling for the entire page */
  html {
    scroll-behavior: smooth;
  }

  /* Prevent any potential margin collapse issues */
  .card-deck-container {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  /* Hide scrollbar on webkit browsers for cleaner look */
  .card-deck-container::-webkit-scrollbar {
    display: none;
  }

  .card-deck-container {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
</style>
